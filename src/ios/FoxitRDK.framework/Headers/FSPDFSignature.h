/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 2.0.6
 *
 * This file is not intended to be easily readable and contains a number of
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG
 * interface file instead.
 * ----------------------------------------------------------------------------- */

/**
 * @file	FSPDFSignature.h
 * @brief	This file contains definitions of object-c APIs for Foxit PDF SDK.
 */

#import "FSCommon.h"
/**
 * @brief	Enumeration for signature states.
 *
 * @details	Values of this enumeration can be used alone or in combination.<br>
 *			These values can be divided into four parts:
 *			<ul>
 *			<li>{@link FS_SIGNATURESTATES::e_signatureStateUnknown FS_SIGNATURESTATES::e_signatureStateXXX} values represent signed state, before signature is verified successfully.</li>
 *			<li>{@link FS_SIGNATURESTATES::e_signatureStateVerifyValid FS_SIGNATURESTATES::e_signatureStateVerifyXXX} values represent the verified state of a signature.</li>
 *			<li>{@link FS_SIGNATURESTATES::e_signatureStateVerifyIssueValid FS_SIGNATURESTATES::e_signatureStateVerifyIssueXXX} values represent the verified state of issue for a signature, with more details.</li>
 *			<li>{@link FS_SIGNATURESTATES::e_signatureStateVerifyTimestampNone FS_SIGNATURESTATES::e_signatureStateVerifyTimestampXXX} values represent the verified state for time stamp, with more details.</li>
 *			</ul>
 */
enum FS_SIGNATURESTATES {
    /** @brief	Unknown signature. */
    e_signatureStateUnknown = 0x00000000,
    /** @brief	Signature does not have any data for signing. */
    e_signatureStateNoSignData = 0x00000200,
    /** @brief	Unsigned signature.*/
    e_signatureStateUnsigned = 0x00000001,
    /** @brief	Signed signature. */
    e_signatureStateSigned = 0x00000002,
    /** @brief	Verification state of a signature is valid. */
    e_signatureStateVerifyValid = 0x00000004,
    /** @brief	Verification state of a signature is invalid. */
    e_signatureStateVerifyInvalid = 0x00000008,
    /** @brief	Signature data is destroyed (the signature data cannot be parsed properly). */
    e_signatureStateVerifyErrorData = 0x00000010,
    /** @brief	Unsupported signature. */
    e_signatureStateVerifyNoSupportWay = 0x00000020,
    /** @brief	Non expected byte range. */
    e_signatureStateVerifyErrorByteRange = 0x00000040,
    /** @brief	The document has changed within the scope of the signature. */
    e_signatureStateVerifyChange = 0x00000080,
    /** @brief	Signature cannot be trusted (containing aggression). */
    e_signatureStateVerifyIncredible = 0x00000100,
    /** @brief	Verification state of the issuer is valid. */
    e_signatureStateVerifyIssueValid = 0x00001000,
    /** @brief	Verification state of the issuer is unknown. */
    e_signatureStateVerifyIssueUnknown = 0x00002000,
    /** @brief	Certificate for verifying issuer is revoked. */
    e_signatureStateVerifyIssueRevoke = 0x00004000,
    /** @brief	Certificate for verifying issuer is expired. */
    e_signatureStateVerifyIssueExpire = 0x00008000,
    /** @brief	Not check the issuer. */
    e_signatureStateVerifyIssueUncheck = 0x00010000,
    /** @brief	The verified issue is current issuer. */
    e_signatureStateVerifyIssueCurrent = 0x00020000,
    /** @brief	No timestamp or not check timestamp. */
    e_signatureStateVerifyTimestampNone = 0x00040000,
    /** @brief	The signature is a timestamp signature. */
    e_signatureStateVerifyTimestampDoc = 0x00080000,
    /** @brief	Verification state of the timestamp is valid. */
    e_signatureStateVerifyTimestampValid = 0x00100000,
    /** @brief	Verification state of the timestamp is invalid. */
    e_signatureStateVerifyTimestampInvalid = 0x00200000,
    /** @brief	Verification state of the timestamp is expired. */
    e_signatureStateVerifyTimestampExpire = 0x00400000,
    /** @brief	Verification state of the timestamp issuer is unknown. */
    e_signatureStateVerifyTimestampIssueUnknown = 0x00800000,
    /** @brief	Verification state of the timestamp issuer is valid. */
    e_signatureStateVerifyTimestampIssueInvalid = 0x01000000,
    /** @brief	Verification state of the timestamp time is valid, since the times is before the expiration date. */
    e_signatureStateVerifyTimestampTimeBefore = 0x02000000
};

/**
 * @brief	Enumeration for signature appearance flags.
 *
 * @details	Values of this enumeration can be used alone or in combination.
 */
enum FS_SIGNATUREAPFLAGS {
    /** @brief      If set, show Foxit flag on signature appearance. */
    e_signatureAPFlagFoxitFlag = 0x0001,
    /** @brief      If set, show label on signature appearance. */
    e_signatureAPFlagLabel = 0x0002,
    /** @brief      If set, show reason on signature appearance. */
    e_signatureAPFlagReason = 0x0004,
    /** @brief      If set, show signing time on signature appearance. */
    e_signatureAPFlagSigningTime = 0x0008,
    /** @brief      If set, show distinguish name on signature appearance. */
    e_signatureAPFlagDN = 0x0010,
    /** @brief      If set, show location on signature appearance. */
    e_signatureAPFlagLocation = 0x0020,
    /** @brief      If set, show signer on signature appearance. */
    e_signatureAPFlagSigner = 0x0040,
    /** @brief      If set, show bitmap on signature appearance. */
    e_signatureAPFlagBitmap = 0x0080,
    /** @brief      If set, show text content on signature appearance. */
    e_signatureAPFlagText = 0x0100
};

/**
 * @brief	Enumeration for signature key name.
 *
 * @details	Values of this enumeration should be used alone.
 */
enum FS_SIGNATUREKEYNAME {
    /** @brief	Signature key name: signer. */
    e_signatureKeyNameSigner = 0,
    /** @brief	Signature key name: location. */
    e_signatureKeyNameLocation = 1,
    /** @brief	Signature key name: reason. */
    e_signatureKeyNameReason = 2,
    /** @brief	Signature key name: contact information. */
    e_signatureKeyNameContactInfo = 3,
    /** @brief	Signature key name: distinguish name. */
    e_signatureKeyNameDN = 4,
    /** @brief	Signature key name: text content. */
    e_signatureKeyNameText = 5,
    /** @brief	Signature key name: filter, used to decide which registered signature handler is used to sign/verify signature. */
    e_signatureKeyNameFilter = 6,
    /** @brief	Signature key name: sub filter, used to decide which registered signature handler is used to sign/verify signature. */
    e_signatureKeyNameSubFilter = 7
    
};

/**
 * @brief	Enumeration for signature digest algorithm.
 *
 * @details	Values of this enumeration should be used alone.
 */
enum FS_DIGEST_ALGORITHM {
    /** @brief	Signature digest algorithm: sha1 algorithm. */
    e_digestSHA1 = 0,
    /** @brief	Signature digest algorithm: sha256 algorithm. */
    e_digestSHA256 = 1,
    /** @brief	Signature digest algorithm: sha384 algorithm. */
    e_digestSHA384 = 2,
    /** @brief	Signature digest algorithm: sha512 algorithm. */
    e_digestSHA512 = 3
};


/**
 * @brief	Class to represent a callback object to sign or verify signature.
 *
 * @details	All the pure virtual functions in this class are used as callback functions
 *			and should be implemented by user, in order to sign or verify signature in a customized way.<br>
 *			User can set a customized signature handler to Foxit PDF SDK by function {@link FSLibrary::registerSignatureHandler:subFilter:signatureHandler:}
 *			with filter and sub filter as the handler name.
 *
 * @see	FSLibrary
 */
@interface FSSignatureCallback : NSObject
{
    void *swigCPtr;
    BOOL swigCMemOwn;
}
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/**
 * @brief	A callback function used to start a custom digest calculation, mainly to initialize the calculation process.
 *
 * @param[in]	file			When signing a signature, this represents the source file object to be signed.<br>
 *								When verifying a signature field, this represents the source file object to be verified.
 * @param[in]	byteRangeArray	A byte range array of the signed document(not the source document).<br>
 *								Elements in this array always be in pairs of offset-size values in order of : offset,size,offset,size...
 * @param[in]	signature		A signature object.
 * @param[in]	clientData		Pointer to a user-defined object, which is passed by user from function {@link FSSignature::startSign:certPath:certPassword:digestAlgorithm:pause:clientData:} or {@link FSSignature::startVerify:clientData:}.
 *
 * @return	<b>TRUE</b> means the calculation process is successfully started and then {@link FSSignatureCallback::continueCalcDigest:clientData:} will be triggered to continue the calculation process.
 *			<b>FALSE</b> means fail to start a calculation process.
 */
-(BOOL)startCalcDigest: (FSFileReadCallback*)file byteRangeArray: (NSArray<NSNumber*> *)byteRangeArray signature: (FSSignature*)signature clientData: (void*)clientData;
/**
 * @brief	A callback function used to continue the custom digest calculation process.
 *
 * @param[in]	pause			Pause object which decides if the calculation process needs to be paused.
 *								If this is <b>NULL</b>, it means not to pause during the calculation process.
 *								If this is not <b>NULL</b>, please check the returned value of {@link FSPauseCallback::needPauseNow} and decide when to pause the calculation process.
 * @param[in]	clientData		Pointer to a user-defined object, which is passed by user from function {@link FSSignature::startSign:certPath:certPassword:digestAlgorithm:pause:clientData:} or {@link FSSignature::startVerify:clientData:}.
 *
 * @return	{@link FS_PROGRESSSTATE::e_progressFinished} means the rendering is finished successfully.<br>
 *			{@link FS_PROGRESSSTATE::e_progressToBeContinued} means the calculation process is not finished yet and callback function {@link FSSignatureCallback::continueCalcDigest:clientData:}
 *			would be triggered again to continue the process.<br>
 *			{@link FS_PROGRESSSTATE::e_progressError} means any error occurs.
 */
-(enum FS_PROGRESSSTATE)continueCalcDigest: (FSPauseCallback*)pause clientData: (void*)clientData;
/**
 * @brief	A callback function used to get the digest after the calculation process is finished.
 *
 * @details	This callback function will be triggered when the calculation process is finished successfully.
 *
 * @param[in]	clientData		Pointer to a user-defined object, which is passed by user from function {@link FSSignature::startSign:certPath:certPassword:digestAlgorithm:pause:clientData:} or {@link FSSignature::startVerify:clientData:}.
 *
 * @return	The digest string. A digest buffer is not required to be a UTF-8 string.
 *			If there is any error, please return an empty string.
 */
-(NSData *)getDigest: (void*)clientData;
/**
 * @brief	A callback function used to do signing and return the signed data.
 *
 * @details	Host application provides this callback method for custom sign mechanism.
 *			This callback function would be triggered during the signature signing process.
 *
 * @param[in]	digest			The digest data buffer, for source file buffer to be signed.
 * @param[in]	certPath		    The certificate file path, which will be used for signing. It would be in UTF-8 encoding.
 * @param[in]	password		The password string, used to open the cert file. If this is <b>NULL</b> or empty, that means no password is required.
 * @param[in]	digestAlgorithm 	The algorithm of message digest for signed data. Please refer to {@link FS_DIGEST_ALGORITHM::e_digestSHA1 FS_DIGEST_ALGORITHM::e_digestXXX} values
 *								and it would be one of these values.
 * @param[in]	clientData		Pointer to a user-defined object, which is passed by user from function {@link FSSignature::startSign:certPath:certPassword:digestAlgorithm:pause:clientData:} or {@link FSSignature::startVerify:clientData:}.
 *
 * @return	Signed data. A signed buffer is not required to be a UTF-8 string.
 *			Currently, its length should be within 7442.
 *			If there is any error, please return an empty string.
 */
-(NSData *)sign: (NSData*)digest certPath: (NSString *)certPath password: (NSString *)password digestAlgorithm: (unsigned int)digestAlgorithm clientData: (void*)clientData;
/**
 * @brief	A callback function used to do verifying and return the verify state.
 *
 * @details	Host application provides this callback method for custom sign mechanism.
 *			This callback function would be triggered during the signature verifying process.
 *
 * @param[in]	digest		The digest data buffer, for source file buffer to be verified. A digest buffer is not required to be a UTF-8 string.
 * @param[in]	signedData	The signed data buffer. A signed buffer is not required to be a UTF-8 string.
 * @param[in]	clientData	Pointer to a user-defined object, which is passed by user from function {@link FSSignature::startSign:certPath:certPassword:digestAlgorithm:pause:clientData:} or {@link FSSignature::startVerify:clientData:}.
 *
 * @return	Verify state.
 *			Please refer to {@link FS_SIGNATURESTATES::e_signatureStateVerifyValid FS_SIGNATURESTATES::e_signatureStateVerifyXXX} values and it should be one or a combination of them.
 */
-(unsigned int)verifySigState: (NSData*)digest signedData: (NSData*)signedData clientData: (void*)clientData;

-(void)dealloc;

@end

/**
 * @brief	Class to represent a signature.
 *
 * @details	A digital signature (PDF 1.3) can be used to authenticate the identity of a user and the document's contents.
 *			It stores information about the signer and the state of the document when it was signed.
 *			The signature is contained in a signature field, as a type of form field, so class ::FSSignature is derived from class ::FSFormControl.
 *			A ::FSSignature object can be gotten/added by following methods:
 *			<ul>
 *			<li>To count and get signature from document, use functions {@link FSPDFDoc::getSignatureCount} and {@link FSPDFDoc::getSignature:}.</li>
 *			<li>To add a new signature, use function {@link FSPDFPage::addSignature:}.</li>
 *			<li>If the related field type of a ::FSFormControl object is {@link FSM_FORMFIELDTYPE::e_formFieldSignature}, the essential class of this form control is ::FSSignature.
 *				So this ::FSFormControl object can be converted to be used as a ::FSSignature object.</li>
 *			</ul>
 *			In a signature, filter and sub filter keys are used to specify the name of signature handler which will be used to sign and verify the signature.
 *			Before sign a signature, please ensure the signature handler has been registered to Foxit PDF SDK with the same filter and sub filter of the signature.
 *			Before verify a signature, please ensure a signature handler with the same name, which is specified by signature's filter and sub filter keys, has been registered to Foxit PDF SDK.
 *			Function {@link FSLibrary::registerDefaultSignatureHandler} can be used to register the default AdobePPKLite handler, with filter ("Adobe.PPKLite") and sub filter ("adbe.pkcs7.detached" or
 *             "adbe.pkcs7.sha1").
 *			This class offers functions to access signature information/properties, sign or verify a signature, and so on. For example:
 *			<ul>
 *			<li>To sign an unsigned signature, use functions {@link FSSignature::startSign:certPath:certPassword:digestAlgorithm:pause:clientData:} and {@link FSSignature::continueSign}.
 *				When signing a signature successfully, user is strongly recommended to close current document and then open the signed PDF document to do following operation.</li>
 *			<li>To verify a signed signature, use functions {@link FSSignature::startVerify:clientData:} and {@link FSSignature::continueVerify}.</li>
 *			<li>To access signature dictionary directly, use function {@link FSSignature::getSignatureDict}.</li>
 *			</ul>
 *			Before signing an unsigned signature, user can call following functions to set information for signing and signed appearance:<br>
 *			{@link FSSignature::setAppearanceFlags:}, {@link FSSignature::setSigningTime:}, {@link FSSignature::setKeyValue:value:}, {@link FSSignature::setBitmap:},
 *			{@link FSSignature::setAppearanceContent:}.<br>
 *			If an unsigned signature has been set some information for signing, but the document is saved directly or closed without signing the signature,
 *			these data (including filter and sub filter) will be lost in the saved document or in the closed document. When the document is opened again,
 *			the unsigned signature needs to be specified at least filter and sub filter for signing; otherwise, this signature cannot be signed.
 *
 * @see	FSFormControl
 * @see FSPDFDoc
 * @see FSPDFPage
 */
@interface FSSignature : FSFormControl
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;

/**
 * @brief	Check whether current signature is signed or not.
 *
 * @return	<b>YES</b> means current signature is signed, and <b>NO</b> means not.
 */
-(BOOL)isSigned;

/**
 * @brief	Start signing current signature if current signature is unsigned.
 *
 * @details	This function is used for an unsigned signature.
 *			Filter and sub filter keys of current signature specify the name of signature handler which will be used to sign current signature.
 *			So before signing, please ensure:
 *			<ul>
 *			<li>Current signature has valid filter and sub filter string values.</li>
 *			<li>The necessary signature handler has been registered by function {@link FSLibrary::registerDefaultSignatureHandler} (for default siganture handler).</li>
 *			</ul>
 *			It may take a long time to sign a signature, so Foxit PDF SDK uses a progressive process to do this.<br>
 * 			If the signing proecess is not finished, please call function {@link FSSignature::continueSign} to continue the signing process until it is finished.
 *
 * @param[in]	savePath		A full PDF file path for saving the signing result, including file name and extension. It should be in UTF-8 encoding.<br>
 *								The signed document would be saved to another PDF file.
 * @param[in]	certPath		A full path of a pfx certificate file (including file name and extension), which will be used for signing.
 *								It should be in UTF-8 encoding. And it should be a valid path.
 * @param[in]	certPassword	The password string, used to open the cert file. If this is <b>nil</b> or empty, that means no password is required.
 *								It should be valid if parameter <i>passwordLen</i> is above 0.
 * @param[in]	digestAlgorithm	The algorithm of message digest for signed data. Please refer to {@link FS_DIGEST_ALGORITHM::e_digestSHA1 FS_DIGEST_ALGORITHM::e_digestXXX} values
 *								and it should be one of these values.
 * @param[in]	pause			Pause object which decides if the signing process needs to be paused.
 *								This can be <b>nil</b> which means not to pause during the signing process.
 *								If this is not <b>nil</b>, it should be a valid pause object implemented by user.
 * @param[in]	clientData		Pointer to a user-defined object, which will be passed to call back functions in FSSignatureCallback.
 *								This is useless if the default handler will be used to sign current signature.
 *
 * @return	{@link FS_PROGRESSSTATE::e_progressFinished} means the signing is finished successfully.<br>
 *			{@link FS_PROGRESSSTATE::e_progressToBeContinued} means the signing process is not finished yet and function {@link FSSignature::continueSign} should be called to continue the process.
 *			{@link FS_PROGRESSSTATE::e_progressError} means any error occurs.
 *
 * @note	When signing a signature successfully, user is strongly recommended to close current document and then open the signed PDF document to do following operation.
 *
 * @exception	e_errParam		Value of input parameter is invalid.
 * @exception	e_errFormat		Any input UTF-8 string parameter is not in UTF-8 encoding.
 * @exception	e_errUnknown	Any unknown error occurs.
 */
-(enum FS_PROGRESSSTATE)startSign: (NSString *)savePath certPath: (NSString *)certPath certPassword: (NSString*)certPassword digestAlgorithm: (enum FS_DIGEST_ALGORITHM)digestAlgorithm pause: (FSPauseCallback*)pause clientData: (void*)clientData;

/**
 * @brief	Continue signing process.
 *
 * @return	{@link FS_PROGRESSSTATE::e_progressFinished} means the signing is finished successfully.<br>
 *			{@link FS_PROGRESSSTATE::e_progressToBeContinued} means the signing process is not finished yet and function {@link FSSignature::continueSign} should be called to continue the process.
 *			{@link FS_PROGRESSSTATE::e_progressError} means any error occurs.
 */
-(enum FS_PROGRESSSTATE)continueSign;

/**
 * @brief	Start verifying current signature if current signature is signed.
 *
 * @details	This function is used for a signed signature.
 *			Filter and sub filter keys of current signature specify the name of signature handler which will be used to verify current signature.
 *			So before verifying, please ensure the necessary signature handler has been registered by function {@link FSLibrary::registerDefaultSignatureHandler} (for default siganture handler) or
 *			by function {@link FSLibrary::registerDefaultSignatureHandler} (for customized signature handler).<br>
 *			It may take a long time to verify a signature, so Foxit PDF SDK uses a progressive process to do this.<br>
 * 			If the verifying proecess is not finished, please call function {@link FSSignature::continueVerify} to continue the verifying process until it is finished.
 *
 * @param[in]	pause			Pause object which decides if the verifying process needs to be paused.
 *								This can be <b>nil</b> which means not to pause during the verifying process.
 *								If this is not <b>nil</b>, it should be a valid pause object implemented by user.
 * @param[in]	clientData		Pointer to a user-defined object, which will be passed to call back functions in FSSignatureCallback.
 *								This is useless if the default handler will be used to verify current signature.
 *
 * @return	{@link FS_PROGRESSSTATE::e_progressFinished} means the verifying is finished successfully.<br>
 *			{@link FS_PROGRESSSTATE::e_progressToBeContinued} means the verifying process is not finished yet and function {@link FSSignature::continueVerify} should be called to continue the process.
 *			{@link FS_PROGRESSSTATE::e_progressError} means any error occurs.
 */
-(enum FS_PROGRESSSTATE)startVerify: (FSPauseCallback*)pause clientData:(void*)clientData;

/**
 * @brief	Continue verifying process.
 *
 * @return	{@link FS_PROGRESSSTATE::e_progressFinished} means the verifying is finished successfully.<br>
 *			{@link FS_PROGRESSSTATE::e_progressToBeContinued} means the verifying process is not finished yet and function {@link FSSignature::continueVerify} should be called to continue the process.
 *			{@link FS_PROGRESSSTATE::e_progressError} means any error occurs.
 */
-(enum FS_PROGRESSSTATE)continueVerify;

/**
 * @brief	Get certificate information.
 *
 * @details	This function is used for a signed signature.
 *			Currently, this function only supports for iOS and android platform.
 *
 * @param[in]	key		Certificate key string, in UTF-8 encoding.
 *						Currently it can be one of the following keys:<br>
 *						<ul>
 *						<li>"SerialNumber"</li>
 *						<li>"Issuer"</li>
 *						<li>"Subject"</li>
 *						<li>"ValidPeriodFrom"</li>
 *						<li>"ValidPeriodTo"</li>
 *						</ul>
 *
 * @return	Certificate information string, in UTF-8 string.
 *
 * @note	For "ValidPeriodFrom" or "ValidPeriodTo" key, timezone value will not be computed in.
 *
 * @exception	e_errParam		Value of input parameter is invalid.
 * @exception	e_errFormat		Any input UTF-8 string parameter is not in UTF-8 encoding.
 */
-(NSString *)getCertificateInfo: (NSString *)key;

/**
 * @brief	Get the byte ranges data, including 4 elements.
 *
 * @details	This function is used for a signed signature.
 *			The array of byte ranges contains 4 elements. These 4 elements are always in pairs of offset-size values,
 *			and is in such order: offset,size,offset,size.
 *
 * @return	An array which can contain 4 elements and is used to receives data of byte ranges.
 */
-(NSArray *)getByteRanges;

/**
 * @brief	Get current state.
 *
 * @details	<ul>
 *			<li>Before verifying a signature, this function is to get the state about if current signature is signed
 *				or if current signature is lack of data for signing.</li>
 *			<li>After verifying a signature, this function is to get the verified state -- which indicates that the verified signature is signed;
 *				if the verified signature is still unsigned, this function will get the unsigned state instead.</li>
 *			</ul>
 *
 * @return	The value of signature state.
 *			Please refer to {@link FS_SIGNATURESTATES::e_signatureStateUnknown FS_SIGNATURESTATES::e_signatureStateXXX} values and it would be one or combination of them.<br>
 *			Specially, if the returned state is {@link FS_SIGNATURESTATES::e_signatureStateNoSignData}, that means current signature has no data for signing,
 *			and please at least call function {@link FSSignature::setKeyValue:value:} to set necessary filter and sub filter to current signature.
 *			Use can also call following functions to set other data for signing and signed appearance before calling function {@link FSSignature::startSign:certPath:certPassword:digestAlgorithm:pause:clientData:}<br>
 *			{@link FSSignature::setAppearanceFlags:}, {@link FSSignature::setSigningTime:}, {@link FSSignature::setKeyValue:value:}, {@link FSSignature::setBitmap:},
 *			{@link FSSignature::setAppearanceContent:}.
 */
-(unsigned int)getState;

/**
 * @brief	Clear the data and appearance if current signature is singed and verified valid.
 *
 * @details   This function is used for a signed and valid signature.
 *
 * @return	<b>YES</b> means clear the data and appearance successfully, while <b>NO</b> means no need to clear data and appearance or any error.
 */
-(BOOL)clearSignedData;

/**
 * @brief	Get the PDF document, which current signature belongs to.
 *
 * @return	A ::FSPDFDoc object.
 */
-(FSPDFDoc*)getDocument;

/**
 * @brief	Get signature appearance flags.
 *
 * @details	Signature appearance flags indicate which information will be shown.
 *			Currently, this is only useful after {@link FSSignature::setAppearanceFlags:} is called successfully.
 *			For a signature gotten from PDF document, returned value of this function would be useless.
 *
 * @return	Signature appearance flags.
 *			Please refer to {@link FS_SIGNATUREAPFLAGS::e_signatureAPFlagFoxitFlag FS_SIGNATUREAPFLAGS::e_signatureAPFlagXXX} values and it would be one or a combination of them.
 */
-(unsigned int)getAppearanceFlags;

/**
 * @brief	Set signature appearance flags.
 *
 * @details	This function is recommended to be used before calling function {@link FSSignature::startSign:certPath:certPassword:digestAlgorithm:pause:clientData:} for an unsigned signature. <br>
 *			Signature appearance flags indicate which information will be shown in the signed appearance.
 *			If customized appearance content has been set by function {@link FSSignature::setAppearanceContent:}, appearance flags will be ignored.
 *
 * @param[in]	apFlags	Signature appearance flags.
 *						Please refer to {@link FS_SIGNATUREAPFLAGS::e_signatureAPFlagFoxitFlag FS_SIGNATUREAPFLAGS::e_signatureAPFlagXXX} values and it should be one or a combination of them.
 */
-(void)setAppearanceFlags: (unsigned int)apFlags;

/**
 * @brief	Get time of signing.
 *
 * @return	A Foxit::DateTime object that receives the signing time.
 *			If no signing time is found or any error, this function will return a ::FSDateTime with all values 0.
 */
-(FSDateTime*)getSigningTime;

/**
 * @brief	Set time of signing.
 *
 * @details	This function is recommended to be used before calling function {@link FSSignature::startSign:certPath:certPassword:digestAlgorithm:pause:clientData:} for an unsigned signature.
 *
 * @param[in]	signTime	The signing time.
 */
-(void)setSigningTime: (FSDateTime*)signTime;

/**
 * @brief	Get the string value for specified key name.
 *
 * @details	This function is used to get string value of some key in signature dictionary, such as "Reason", "Location" and so on.
 *			Specially, filter and sub filter are used to specify which registered signature handler will be used to sign/verify current signature.
 *
 * @param[in]	key		Key name.
 *						Please refer to {@link FS_SIGNATUREKEYNAME::e_signatureKeyNameSigner FS_SIGNATUREKEYNAME::e_signatureKeyNameXXX} values and it should be one of them.
 *
 * @return	The string value:
 *          <ul>
 *          <li>For key values {@link FS_SIGNATUREKEYNAME::e_signatureKeyNameFilter} and
 *              {@link FS_SIGNATUREKEYNAME::e_signatureKeyNameSubFilter}, the returend string is in ASCII encoding.</li>
 *          <li>For rest key values, the returned string is in UTF-8 encoding.</li>
 *          </ul>
 */
-(NSString *)getKeyValue: (enum FS_SIGNATUREKEYNAME)key;

/**
 * @brief	Set the string value for specified key name.
 *
 * @details	This function is recommended to be used before calling function {@link FSSignature::startSign:certPath:certPassword:digestAlgorithm:pause:clientData:} for an unsigned signature.<br>
 *			This function is used to set string value of some key in signature dictionary, such as signer, reason, location and so on.
 *			Specially, filter and sub filter are used to specify which registered signature handler will be used to sign/verify current signature.<br>
 *			If application does not set filter and sub filter for current signature, Foxit PDF SDK will use filter "Adobe.PPKLite" and sub filter"adbe.pkcs7.detached" by default.
 *			And application should ensure to register a signature handler with this filter and sub filter before signing or verifying current signature.<br>
 *			If application wants to use other signature handler, please set the filter and sub filter name of that signature handler to current signature,
 *			and also ensure the handler has been registered before signing and verifying current signature.<br>
 *
 * @param[in]	key		Key name.
 *						      Please refer to {@link FS_SIGNATUREKEYNAME::e_signatureKeyNameSigner FS_SIGNATUREKEYNAME::e_signatureKeyNameXXX} values and it should be one of them.
 * @param[in]	value	New string value:
 *                  <ul>
 *                  <li>For key values {@link FS_SIGNATUREKEYNAME::e_signatureKeyNameFilter} and
 *                      {@link FS_SIGNATUREKEYNAME::e_signatureKeyNameSubFilter}, the input string should be in ASCII encoding.</li>
 *                  <li>For rest key values, the returned string should be in UTF-8 encoding.</li>
 *                  </ul>
 *                  This should not be <b>NULL</b> or empty, if parameter <i>key</i> is {@link FS_SIGNATUREKEYNAME::e_signatureKeyNameFilter}.
 *
 * @return	None.
 *
 * @exception	e_errParam		Value of input parameter is invalid.
 * @exception	e_errFormat		Any input UTF-8 string parameter is not in UTF-8 encoding.
 * @exception	e_errUnknown	Any unknown error occurs.
 */
-(void)setKeyValue: (enum FS_SIGNATUREKEYNAME)key value: (NSString *)value;

/**
 * @brief	Get a bitmap used for the signature appearance.
 *
 * @return	The bitmap used in appearance.
 *			If no bitmap is used in appearance or there is any error, <b>nil</b> will be returned.
 */
-(FSBitmap*)getBitmap;

/**
 * @brief	Set a bitmap for the signature appearance.
 *
 * @details	This function is recommended to be used before calling function {@link FSSignature::startSign:certPath:certPassword:digestAlgorithm:pause:clientData:} for an unsigned signature.
 *			If customized appearance content has been set by function {@link FSSignature::setAppearanceContent:}, the bitmap will not be used in signed appearance.
 *
 * @param[in]	bitmap		A bitmap to be set to the appearance. It should be valid.
 */
-(void)setBitmap: (FSBitmap*)bitmap;

/**
 * @brief	Get signature dictionary.
 *
 * @details	Signature dictionary is a part of signature field dictionary.
 *
 * @return	The signature dictionary.
 *			If there is any error, this function will return <b>nil</b>.
 */
-(FSPDFDictionary*)getSignatureDict;

/**
 * @brief	Set customized appearance content (as low level drawing commands) for signed signature appearance.
 *
 * @details	This function can only be used for an unsigned signature, before calling function {@link FSSignature::startSign:certPath:certPassword:digestAlgorithm:pause:clientData:} for the unsigned signature.
 *			Once customized appearance content is set, it will be used as the signed appearance and appearance flags set by function {@link FSSignature::setAppearanceFlags:} will be ignored.
 *
 * @param[in]	appearanceContent		Customized appearance content, in UTF-8 encoding.
 *										A sequence of drawing commands to be used for the appearance, for example "10 10 m 20 10 l S".
 *
 * @exception	e_errFormat		Any input UTF-8 string parameter is not in UTF-8 encoding.
 */
-(void)setAppearanceContent: (NSString *)appearanceContent;

/** @brief Free the object. */
-(void)dealloc;

@end
