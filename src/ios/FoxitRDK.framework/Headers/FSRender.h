/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 2.0.6
 *
 * This file is not intended to be easily readable and contains a number of
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG
 * interface file instead.
 * ----------------------------------------------------------------------------- */

/**
 * @file	FSRender.h
 * @brief	This file contains definitions of object-c APIs for Foxit PDF SDK.
 */

#import "FSCommon.h"

@class FSLayerContext;

/************************************************************************************************
 *									Render   													*
 *************************************************************************************************/

/**
 * @brief	Class to access a bitmap.
 *
 * @details	Bitmap is one of most important data structures in Foxit PDF SDK.
 *			It is commonly used for rendering.
 */
@interface FSBitmap : NSObject
{
    /** @brief SWIG proxy related property, it's deprecated to use it. */
    void *swigCPtr;
    /** @brief SWIG proxy related property, it's deprecated to use it. */
    BOOL swigCMemOwn;
}
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/**
 * @brief	Create a bitmap.
 *
 * @details	If the parameter <i>buffer</i> is not <b>nil</b>, it should be initialized by application;
 *			otherwise, Foxit PDF SDK will allocate and initialize the pixels buffer internally. <br>
 *			Application is suggested to use the same colors to initialize bitmap' pixels buffer as Foxit PDF SDK uses internally:
 *			<ul>
 *			<li>For the bitmap without alpha channel, initialize the pixels buffer with 0xFFFFFFFF.</li>
 *			<li>For the bitmap with alpha channel, initialize the pixels buffer with 0x00000000.</li>
 *			</ul>
 *
 * @param[in]	width		Width of a bitmap, in pixels. This should be above 0.
 * @param[in]	height		Height of a bitmap, in pixels. This should be above 0.
 * @param[in]	format		Bitmap format type.
 *							Please refere to {@link FS_DIBFORMAT::e_dibRgb FS_DIBFORMAT::e_dibXXX} values and it should be one of these values,
 *							except {@link FS_DIBFORMAT::e_dibInvalid}.
 * @param[in]	buffer		A buffer that specifies bitmap data.<br>
 *							If it is not <b>nil</b>, this function will use the parameter <i>buffer</i> to initialize a bitmap.
 *							Please keep the buffer valid during the life-cycle of the bitmap.<br>
 * 							If it is <b>nil</b>, a new bitmap buffer will be created internally.
 * @param[in]	pitch		The number of bytes for each scan line and only useful when parameter <i>buffer</i> is used.
 *							If 0, 4-byte alignment is assumed.
 *
 * @return	A new bitmap instance.
 */
+(FSBitmap*)create: (int)width height: (int)height format: (enum FS_DIBFORMAT)format buffer: (unsigned char *)buffer pitch: (int)pitch;
/**
 * @brief	Clone current bitmap, with specified clip rectangle.
 *
 * @param[in]	clip	The clipping region in current bitmap, which is to be cloned. <br>
 *						<ul>
 *						<li> For rest format, this can be either <b>nil</b> or valid.  If this is <b>nil</b>, that means to clone the whole bitmap.
 *							 If this is not <b>nil</b>, it specifies a clipping region in bitmap to be cloned
 *							 and the cloned bitmap will have the same size as the clipping region.
 *						</li>
 *						</ul>
 *
 * @return	A new bitmap as clone result.
 */
-(FSBitmap*)clone: (FSRectI*)clip;
/**
 * @brief	Get bitmap width.
 *
 * @return	Bitmap width.
 *			If any error occurs, -1 will be returned.
 */
-(int)getWidth;
/**
 * @brief	Get bitmap height.
 *
 * @return	Bitmap height.
 *			If any error occurs, -1 will be returned.
 */
-(int)getHeight;
/**
 * @brief	Get bitmap pitch.
 *
 * @return	Bitmap pitch.
 *			If any error occurs, -1 will be returned.
 */
-(int)getPitch;
/**
 * @brief	Get bitmap bits-per-pixel.
 *
 * @return	Bitmap bits-per-pixel value.
 *			If any error occurs, -1 will be returned.
 */
-(int)getBpp;
/**
 * @brief	Get bitmap buffer.
 *
 * @details	Bitmap data are organized in scan-lines, from top to down.
 *
 * @return	Bitmap buffer data.
 *			If any error occurs, <b>nil</b> will be returned.
 */
-(NSData *)getBuffer;
/**
 * @brief	Get bitmap format.
 *
 * @return	Format value.
 *			Please refer to {@link FS_DIBFORMAT::e_dibInvalid FS_DIBFORMAT::e_dibXXX} values and this would be one of these values.
 */
-(enum FS_DIBFORMAT)getFormat;
/**
 * @brief	Fill current bitmap with a specified color.
 *
 * @param[in]	color		Color that used to fill bitmap. Format: 0xAARRGGBB
 * @param[in]	rect		Rectangle that specifies a region in bitmap, where the color will be filled.
 *							This can be <b>nil</b>, which means to fill the whole bitmap.
 */
-(void)fillRect: (unsigned int)color rect: (FSRectI*)rect;

/** @brief Free the object. */
-(void)dealloc;

@end
/**
 * @brief	Enumeration for render color mode.
 *
 * @details	Values of this enumeration can be used alone.
 */
enum FS_RENDERCOLORMODE {
    /** @brief	Normal color mode. */
    e_colorModeNormal = 0,
    /** @brief	Map a color value to the color range defined by a background color and a foreground color. */
    e_colorModeMapping = 2
};

/**
 * @brief	Enumeration for render content flags.
 *
 * @details	Values of this enumeration can be used alone or in combination.
 */
enum FS_RENDERCONTENTFLAG {
    /** @brief	If set, page content will be rendered. */
    e_renderPage = 0x01,
    /** @brief	If set, annotations will be rendered. */
    e_renderAnnot = 0x02
};

/**
 * @brief	Enumeration for render device type.
 *
 * @details	Values of this enumeration can be used alone.
 */
enum FS_DEVICETYPE {
    /** @brief	Device type: printer. */
    e_deviceTypePrinter = 0,
    /** @brief	Device type: display device. */
    e_deviceTypeDisplay = 1
};

/**
 * @brief	Class to access PDF render operation.
 *
 * @details	PDF renderer is a graphics engine and is used to render page to a bitmap or a device.
 *			This class offers functions to set rendering options, and render page and annotations. <br>
 *			A ::FSRenderer object is created by function {@link FSRenderer::create:rgbOrder:} or {@link FSRenderer::createFromContext:deviceType:}.
 *			There are two ways to do rendering:
 *			<ul>
 *			<li>To render page and annotations, use functions {@link FSRenderer::startRender:matrix:pause:} and {@link FSRenderer::continueRender}.
 *				Function {@link FSRenderer::setRenderContent:} can be used to decide whether to render page and annotation both or not.</li>
 *			<li>To render a single annotation, use function {@link FSRenderer::renderAnnot:matrix:}.</li>
 *			</li>
 *			<li>To render a bitmap, use function {@link FSRenderer::startRenderBitmap:matrix:clipRect:interpolation:pause:} and {@link FSRenderer::continueRender}.</li>
 *			<li>To render a reflow page, use function {@link FSRenderer::startRenderReflowPage:matrix:pause:} and {@link FSRenderer::continueRender}.</li>
 *			</ul>
 */
@interface FSRenderer : NSObject
{
    /** @brief SWIG proxy related property, it's deprecated to use it. */
    void *swigCPtr;
    /** @brief SWIG proxy related property, it's deprecated to use it. */
    BOOL swigCMemOwn;
}
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/**
 * @brief	Create a renderer object from bitmap.
 *
 * @param[in]	bitmap		A bitmap used for rendering.
 * @param[in]	rgbOrder	<b>YES</b> means Foxit PDF SDK needs to use RGB byte-order
 *							(Red is in the lowest order) when rendering.<br>
 *							<b>NO</b> means Foxit PDF SDK needs to use BGR byte-order
 *							(Blue is in the lowest order) when rendering.
 *
 * @return	A new renderer object.
 */
+(FSRenderer*)create: (FSBitmap*)bitmap rgbOrder: (BOOL)rgbOrder;
/**
 * @brief	Create a renderer object from device context.
 *
 * @param[in]	context		A CGContextRef object.
 * @param[in]	deviceType	The device type of parameter <i>context</i>.
 *
 * @return	A new renderer object.
 */
+(FSRenderer*)createFromContext: (CGContextRef)context deviceType: (enum FS_DEVICETYPE)deviceType;
/**
 * @brief	Start rendering a PDF page.
 *
 * @details	It will take a long time to render a page with complex or large contents, so Foxit PDF SDK uses a progressive process to do this.<br>
 * 			If the rendering is not finished, please call function {@link FSRenderer::continueRender} to continue the rendering until it is finished.
 *
 * @param[in]	page		A PDF page. It should be parsed.
 * @param[in]	matrix		The transformation matrix used for rendering, which is usually returned by function {@link FSPDFPage::getDisplayMatrix:yPos:xSize:ySize:rotate:}.
 *							If this is <b>nil</b>, a matrix [1 0 0 1 0 0] will be used instead.
 * @param[out]	pause		Pause object which decides if the rendering process needs to be paused.
 *							This can be <b>nil</b> which means not to pause during the rendering process.
 *							If this is not <b>nil</b>, it should be a valid pause object implemented by user.
 *
 * @return	{@link FS_PROGRESSSTATE::e_progressFinished} means the rendering is finished successfully.<br>
 *			{@link FS_PROGRESSSTATE::e_progressToBeContinued} means the rendering process is not finished yet
 *			and function {@link FSRenderer::continueRender} should be called to continue the process.<br>
 *			{@link FS_PROGRESSSTATE::e_progressError} means any error occurs.
 */
-(enum FS_PROGRESSSTATE)startRender: (FSPDFPage*)page matrix: (FSMatrix*)matrix pause: (FSPauseCallback*)pause;
/**
 * @brief	Start rendering a reflow page.
 *
 * @details	It will take a long time to render a reflow page with complex or large contents, so Foxit PDF SDK uses a progressive process to do this.<br>
 * 			If the rendering is not finished, please call function {@link FSRenderer::continueRender} to continue the rendering until it is finished.
 *
 * @param[in]	reflowPage		A reflow page. It should be parsed.
 * @param[in]	matrix			The transformation matrix used for rendering, which is usually returned by function {@link FSReflowPage::getDisplayMatrix:offsetY:}.
 * @param[in]	pause			Pause object which decides if the rendering process needs to be paused.
 *								This can be <b>nil</b> which means not to pause during the rendering process.
 *								If this is not <b>nil</b>, it should be a valid pause object implemented by user.
 *
 * @return	{@link FS_PROGRESSSTATE::e_progressFinished} means the rendering is finished successfully.<br>
 *			{@link FS_PROGRESSSTATE::e_progressToBeContinued} means the rendering process is not finished yet
 *			and function {@link FSRenderer::continueRender} should be called to continue the process.<br>
 *			{@link FS_PROGRESSSTATE::e_progressError} means any error occurs.
 *
 * @exception	e_errParam		Value of input parameter1 is invalid.
 */
-(enum FS_PROGRESSSTATE)startRenderReflowPage: (FSReflowPage*)reflowPage matrix: (FSMatrix*) matrix pause: (FSPauseCallback*)pause;
/**
 * @brief	Start rendering a bitmap.
 *
 * @details	It will take a long time to render a bitmap with complex or large contents, so Foxit PDF SDK uses a progressive process to do this.<br>
 *			If the rendering is not finished, please call function {@link FSRenderer::continueRender} to continue the rendering until it is finished.
 *
 * @param[in]	bitmap			A bitmap. It should be valid.
 * @param[in]	matrix			The transformation matrix used for rendering. This matrix is used as image matrix: <br>
 *								assume that <i>h</i> is image height, <i>w</i> is image width, and then matrix [w 0 0 h 0 0] will produce an identical image.
 * @param[in]	clipRect		Clip rectangle of the render device. This can be <b>nil</b>.
 * @param[in]	interpolation	Bitmap interpolation flags.
 *								Please refere to {@link FS_BITMAPINTERPOLATIONFLAG::e_interpolationDownsample FS_BITMAPINTERPOLATIONFLAG::e_interpolationXXX} values
 *								and this can be one or a combination of these values.
 *								This can be 0.
 * @param[in]	pause			Pause object which decides if the rendering process needs to be paused.
 *								This can be <b>nil</b> which means not to pause during the rendering process.
 *								If this is not <b>nil</b>, it should be a valid pause object implemented by user.
 *
 * @return	{@link FS_PROGRESSSTATE::e_progressFinished} means the rendering is finished successfully.<br>
 *			{@link FS_PROGRESSSTATE::e_progressToBeContinued} means the rendering process is not finished yet
 *			and function {@link FSRenderer::continueRender} should be called to continue the process.<br>
 *			{@link FS_PROGRESSSTATE::e_progressError} means any error occurs.
 *
 * @exception	e_errParam			Value of input parameter is invalid.
 v
 * @exception	e_errOutOfMemory	Out-of-memory error occurs.
 */
-(enum FS_PROGRESSSTATE)startRenderBitmap: (FSBitmap*)bitmap matrix: (FSMatrix*)matrix clipRect: (FSRectI*)clipRect interpolation: (int)interpolation pause: (FSPauseCallback*)pause;
/**
 * @brief	Continue rendering process.
 *
 * @return	{@link FS_PROGRESSSTATE::e_progressFinished} means the rendering is finished successfully.<br>
 *			{@link FS_PROGRESSSTATE::e_progressToBeContinued} means the rendering process is not finished yet
 *			and function {@link FSRenderer::continueRender} should be called to continue the process.<br>
 *			{@link FS_PROGRESSSTATE::e_progressError} means any error occurs.
 *
 * @exception	e_errOutOfMemory	Out-of-memory error occurs.
 * @exception	e_errUnknown		Any unknown error occurs.
 */
-(enum FS_PROGRESSSTATE)continueRender;
/**
 * @brief	Render a specified annotation.
 *
 * @details	When this function is called, render flag (set by function {@link FSRenderer::setRenderContent:} or by default) will be ignored.
 *
 * @param[in]	annot		An annotation object to be rendered.
 * @param[in]	matrix		The transformation matrix used for rendering, which is usually returned by {@link FSPDFPage::getDisplayMatrix:yPos:xSize:ySize:rotate:}.
 *							If this is <b>nil</b>, a matrix [1 0 0 1 0 0] will be used instead.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)renderAnnot: (FSAnnot*)annot matrix: (FSMatrix*)matrix;
/**
 * @brief	Set render flag to decide what content will be rendered.
 *
 * @details	If this function is not called, default value ({@link FS_RENDERCONTENTFLAG::e_renderPage} | {@link FS_RENDERCONTENTFLAG::e_renderAnnot}) will be used.
 *
 * @param[in]	renderContentFlag		Render content flags.
 *										Please refere to {@link FS_RENDERCONTENTFLAG::e_renderPage FS_RENDERCONTENTFLAG::e_renderXXX} values
 *										and this should be one or a combination of these values.
 */
-(void)setRenderContent: (unsigned int)renderContentFlag;
/**
 * @brief	Decide whether to transform annotation icon or not when display.
 *
 * @details	The flag set by this function is only useful for note and file attachment annotations.
 *			If this function is not called, default value <b>YES</b> will be used.
 *
 * @param[in]	transformAnnotIcon			<b>YES</b> means to transform annotation icon when display.
 *											<b>NO</b> means not to transform annotation icon when display.
 */
-(void)setTransformAnnotIcon: (BOOL)transformAnnotIcon;

/**
 * @brief	Set layer context to render context handle.
 *
 * @param[in]	layerContext		Handle to a <b>FSLayerContext</b> object which is a PDF layer context object.
 *
 * @note	In order to render one layer when to render PDF contents on a rendering context,
 *			user should call this function to set the layer context to render context.
 */
-(void)setLayerContext: (FSLayerContext*)layerContext;

/**
 * @brief	Set color mode.
 *
 * @details	If this function is not called, default value {@link FS_RENDERCOLORMODE::e_colorModeNormal} will be used.
 *
 * @param[in]	colorMode	Color mode value. It should be one of following values:
 *							<ul>
 *							<li>{@link FS_RENDERCOLORMODE::e_colorModeNormal} means normal color mode.</li>
 *							<li>{@link FS_RENDERCOLORMODE::e_colorModeMapping} means map a color value to the color range defined by a background color and a foreground color.
 *								If this mode is used, please call function {@link FSRenderer::setMappingModeColors:foreColor:} to set "background color" and "foreground color".</li>
 *							</ul>
 */
-(void)setColorMode: (enum FS_RENDERCOLORMODE)colorMode;
/**
 * @brief	Set background color and foreground color when color mode is set {@link FS_RENDERCOLORMODE::e_colorModeMapping}.
 *
 * @param[in]	backColor		The background color.
 * @param[in]	foreColor		The foreground color.
 */
-(void)setMappingModeColors: (unsigned int)backColor foreColor: (unsigned int)foreColor;
/**
 * @brief	Decide whether to use halftone for image stretching.
 *
 * @details	If this function is not called, default value <b>YES</b> will be used.
 *
 * @param[in]	isForceHalftone	<b>YES</b> means to use halftone for image stretching.
 *								<b>NO</b> means not to use halftone for image stretching.
 */
-(void)setForceHalftone: (BOOL)isForceHalftone;

/** @brief Free the object. */
-(void)dealloc;

@end

