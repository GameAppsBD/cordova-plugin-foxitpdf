/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 2.0.6
 *
 * This file is not intended to be easily readable and contains a number of
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG
 * interface file instead.
 * ----------------------------------------------------------------------------- */

/**
 * @file	FSPDFDoc.h
 * @brief	This file contains definitions of object-c APIs for Foxit PDF SDK.
 */

#import "FSCommon.h"
#import "FSPDFSecurity.h"
#import "FSPDFAnnot.h"
#import "FSPDFGraphicsObject.h"

@class FSReadingBookmark;
@class FSBookmark;

/************************************************************************************************
 *									PDF Document					  							*
 *************************************************************************************************/
/**
 * @brief	Enumeration for page label style.
 *
 * @details	Values of this enumeration should be used alone.
 */
enum FS_PAGELABELSTYLE {
    /** @brief	Page label style: no numbering style. */
    e_pageLabelStyleNone	 =	0,
    /** @brief	Page label style: decimal Arabic numerals. */
    e_pageLabelStyleDecimalNums	=	1,
    /** @brief	Page label style: uppercase roman numerals. */
    e_pageLabelStyleUpperRomanNums	=	2,
    /** @brief	Page label style: lowercase roman numerals. */
    e_pageLabelStyleLowerRomanNums	=	3,
    /** @brief	Page label style: uppercase letters (A to Z for the first 26 pages, AA to ZZ for the next 26, and so on). */
    e_pageLabelStyleUpperLetters =	4,
    /** @brief	Page label style: lowercase letters (a to z for the first 26 pages, aa to zz for the next 26, and so on). */
    e_pageLabelStyleLowerLetters =	5
};


/**
 * @brief	Enumeration for password type.
 *
 * @details	Values of this enumeration should be used alone.
 */
enum FS_PASSWORDTYPE {
    /** @brief	The password is invalid. */
    e_pwdInvalid	 =	0,
    /** @brief	No password is used in PDF document. */
    e_pwdNoPassword	=	1,
    /** @brief	A user password is used in PDF document. */
    e_pwdUser	=	2,
    /** @brief	An owner password is used in PDF document. */
    e_pwdOwner	=	3
};

/**
 * @brief	Enumeration for user permissions of a PDF document.
 *
 * @details	Values of this enumeration can be used alone or in combination.
 */

enum FS_USERPERMISSIONS {
    /**
     * @brief	Print PDF document with normal mode. (Bit 3 in permission value)
     *
     * @details	If user wants to print a higher quality level of PDF document, please set current value with {@link FS_USERPERMISSIONS::e_permPrintHigh} together.
     */
    e_permPrint = 0x0004,
    /**
     * @brief	Modify PDF contents. (Bit 4 in permission value)
     *
     * @details	If this value is set, user can modify contents of PDF document
     *			by operations other than those controlled by {@link FS_USERPERMISSIONS::e_permAnnotForm}, {@link FS_USERPERMISSIONS::e_permFillForm} and {@link FS_USERPERMISSIONS::e_permAssemble} values.
     */
    e_permModify	= 0x0008,
    /**
     * @brief	Extract PDF contents. (Bit 5 in permission value)
     *
     * @details	If this value is set, user can copy or otherwise extract text and graphics from the document
     *			by operations other than that controlled by {@link FS_USERPERMISSIONS::e_permExtractAccess} value.
     */
    e_permExtract = 0x0010,
    /**
     * @brief	Operate text annotations and fill in interactive form fields. (Bit 6 in permission value)
     *
     * @details	If {@link FS_USERPERMISSIONS::e_permModify} is also set, user can create or modify interactive form fields (including signature fields).
     */
    e_permAnnotForm = 0x0020,
    /**
     * @brief	Fill PDF form. (Bit 9 in permission value)
     *
     * @details	If this value is set, user can fill in interactive form fields (including signature fields),
     * 			even if {@link FS_USERPERMISSIONS::e_permAnnotForm} is not used.
     */
    e_permFillForm = 0x0100,
    /**
     * @brief	Disabilities support. (Bit 10 in permission value)
     *
     * @details	If this value is set, user can extract text and graphics in support of accessibility to users with disabilities
     *			or for other purposes.
     */
    e_permExtractAccess = 0x0200,
    /**
     * @brief	Assemble PDF document. (Bit 11 in permission value)
     *
     * @details	If this value is set, it enables to assemble the document (insert, rotate, or delete pages
     * 			and create bookmarks or thumbnail images), regardless if {@link FS_USERPERMISSIONS::e_permModify} is set or not.
     */
    e_permAssemble = 0x0400,
    /**
     * @brief	Print PDF document with higher qualities. (Bit 12 in permission value)
     *
     * @details	If this value is not set (and {@link FS_USERPERMISSIONS::e_permPrint} is set), printing is limited to a low-level
     * 			representation of the appearance, possibly of degraded quality.
     */
    e_permPrintHigh = 0x0800
};



/**
 * @brief	Class to represent information of a page labeling range.
 *
 * @details	Page label is used to identify each page visually on the screen or in print,
 *			and can be specified in any way that is appropriate for the particular document.<br>
 *			For purposes of page labeling, a document can be divided into labeling ranges,
 *			each of which is a series of consecutive pages using the same numbering system.
 *			Pages within a range are numbered sequentially in ascending order.
 *			A page's label consists of a numeric portion based on its position within its labeling range,
 *			optionally preceded by a label prefix denoting the range itself. <br>
 *			For example, the pages in an appendix might be labeled with decimal numeric portions prefixed
 *			with the string A-; the resulting page labels would be A-1, A-2, and so on.<br>
 *			This class represents the information of a page labeling range, including numbering style, label prefix
 *			and value of the numeric portion for the first page label in the range.<br>
 */
@interface FSPageLabel : NSObject
{
    /** @brief SWIG proxy related property, it's deprecated to use it. */
    void *swigCPtr;
    /** @brief SWIG proxy related property, it's deprecated to use it. */
    BOOL swigCMemOwn;
}
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/**
 * @brief	Set value.
 *
 * @param[in]	start				The index of first page in current labeling range, starting from 0.
 * @param[in]	style				The numbering style to be used for the numeric portion of each page label.
 *									Please refer to {@link FS_PAGELABELSTYLE::e_pageLabelStyleNone FS_PAGELABELSTYLE::e_pageLabelStyleXXX} and it should be one of these values.
 *									If the value is {@link FS_PAGELABELSTYLE::e_pageLabelStyleNone}, page labels consist solely of a label prefix with no numeric portion.
 * @param[in]	prefix				The label prefix string for page labels in current labeling range.
 *									Only the first 100 characters can be used as label prefix string.
 * @param[in]	firstPageNumber		The value of the numeric portion for the first page label in current labeling range.
 *									Subsequent pages are numbered sequentially from this value, which must be greater than or equal to 1.
 */
-(void)set: (int)start style: (enum FS_PAGELABELSTYLE)style prefix: (NSString *)prefix firstPageNumber: (int)firstPageNumber;
/**
 * @brief	Set the index of first page in current labeling range.
 *
 * @param[in]	value	New index for first page. Valid range: from 0 to (<i>count</i>-1).
 *						<i>count</i> is the page count of the PDF document.
 */
-(void)setStart: (int)value;
/**
 * @brief	Get the index of first page in current labeling range.
 *
 * @return	The index for first page, starting from 0.
 */
-(int)getStart;
/**
 * @brief	Set numbering style.
 *
 * @details	Numbering style is used for the numeric portion of each page label.
 *
 * @param[in]	value	New numbering style.
 *						Please refer to {@link FS_PAGELABELSTYLE::e_pageLabelStyleNone FS_PAGELABELSTYLE::e_pageLabelStyleXXX} and it should be one of these values.
 *						If the value is {@link FS_PAGELABELSTYLE::e_pageLabelStyleNone}, page labels consist solely of a label prefix with no numeric portion.
 */
-(void)setStyle: (enum FS_PAGELABELSTYLE)value;
/**
 * @brief	Get numbering style.
 *
 * @details	Numbering style is used for the numeric portion of each page label.
 *
 * @return	The numbering style.
 *			Please refer to {@link FS_PAGELABELSTYLE::e_pageLabelStyleNone FS_PAGELABELSTYLE::e_pageLabelStyleXXX} and it would be one of these values.
 *			If the value is {@link FS_PAGELABELSTYLE::e_pageLabelStyleNone}, page labels consist solely of a label prefix with no numeric portion.
 */
-(enum FS_PAGELABELSTYLE)getStyle;
/**
 * @brief	Set label prefix.
 *
 * @param[in]	value	New label prefix string.
 *						Only the first 100 characters can be used as label prefix string.
 */
-(void)setPrefix: (NSString *)value;
/**
 * @brief	Get label prefix.
 *
 * @return	Label prefix string.
 */
-(NSString *)getPrefix;
/**
 * @brief	Set the value of the numeric portion for the first page label
 *
 * @details	Subsequent pages are numbered sequentially from this value,
 *			which must be greater than or equal to 1
 *
 * @param[in]	value	New value of the numeric portion.
 */
-(void)setFirstPageNumber: (int)value;
/**
 * @brief	Get the value of the numeric portion for the first page label
 *
 * @details	Subsequent pages are numbered sequentially from this value,
 *			which must be greater than or equal to 1
 *
 * @return	Value of the numeric portion.
 */
-(int)getFirstPageNumber;
/** @brief Initialize the object. */
-(id)init;

/** @brief Free the object. */
-(void)dealloc;

@end


/**
 * @brief	Enumeration for PDF document saving flags.
 *
 * @details	Values of this enumeration can be used alone or in combination.
 */
enum FS_SAVEFLAGS {
    /** @brief	Save document normally, without using any special flag. This can only be used alone.*/
    e_saveFlagNormal = 0,
    /**
     * @brief	Save document incrementally.
     *
     * @details	This can be used alone or be combined with other saving flags except {@link FS_SAVEFLAGS::e_saveFlagNormal}.
     *			Especially, if this is combined with {@link FS_SAVEFLAGS::e_saveFlagNoOriginal}, only the increment data will be saved.
     */
    e_saveFlagIncremental = 0x0001,
    /**
     * @brief	Save document without original data or unchanged objects.
     *
     * @details	This can be used alone or be combined with other saving flags except {@link FS_SAVEFLAGS::e_saveFlagNormal}.
     *			Especially, if this is combined with {@link FS_SAVEFLAGS::e_saveFlagIncremental}, only the increment data will be saved.
     */
    e_saveFlagNoOriginal = 0x0002,
    /**
     * @brief	Save document by using object stream, in order to reduce the file size.
     *
     * @details	This can be used alone or be combined with other saving flags except {@link FS_SAVEFLAGS::e_saveFlagNormal}.
     */
    e_saveFlagObjectStream = 0x0004
};

/**
 * @brief	Enumeration for flags for importing pages.
 *
 * @details	Values of this enumeration can be used alone or in combination.
 */
enum FS_IMPORTFLAGS {
    /** @brief	Import pages normally.*/
    e_importFlagNormal = 0,
    /** @brief	Import pages with layers.*/
    e_importFlagWithLayers = 0x0001,
    /**
     * @brief	Import pages without cloning stream objects into memory.
     *
     * @details	This flags is only useful when the source PDF document has not been encrypted.
     *			If this flag is used for importing pages, it will reduce memory overhead.
     */
    e_importFlagShareStream = 0x0002
};

/**
 * @brief	Class to access a PDF document.
 *
 * @details	A <CODE>PDFDoc</CODE> object can be created by following functions:
 *			<ul>
 *			<li>{@link FSPDFDoc::createFromFilePath:}: from a specified PDF file path.</li>
 *			<li>{@link FSPDFDoc::createFromMemory:}: from memory buffer which contains the serialized document.</li>
 *			<li>{@link FSPDFDoc::createFromHandler:}: from a customized <CODE>FileRead</CODE> object.</li>
 *			</ul>
 *			After a <CODE>PDFDoc</CODE> object is created, function {@link FSPDFDoc::load:} should be called to load the document content.<br>
 *			This class also offers functions to access different part of a PDF document. For example:
 *			<ul>
 *			<li>To access pages, use functions {@link FSPDFDoc::getPageCount} and {@link FSPDFDoc::getPage:}.</li>
 *			<li>To access bookmark:
 *				<ul>
 *				<li>To access bookmark tree, use function {@link FSPDFDoc::getFirstBookmark}.</li>
 *				<li>To create bookmark root node, use function {@link FSPDFDoc::createFirstBookmark}.</li>
 *				<li>To remove bookmark, use function {@link FSPDFDoc::removeBookmark:}.</li>
 *				</ul>
 *			</li>
 *			<li>To access document information (that is "metadata"), use functions {@link FSPDFDoc::hasMetadataKey:}, {@link FSPDFDoc::getCreationDateTime},
 *				{@link FSPDFDoc::getModifiedDateTime} and {@link FSPDFDoc::getMetadataValue:}.</li>
 *			<li>To access page labeling range information , use functions {@link FSPDFDoc::getPageLabelRangeCount} and {@link FSPDFDoc::getPageLabelInfo:}.
 *			</li>
 *			<li>To access document catalog dictionary (in low-level), use function {@link FSPDFDoc::getCatalog}.</li>
 *			<li>To access document trailer dictionary (in low-level), use function {@link FSPDFDoc::getTrailer}.</li>
 *			<li>To access document information dictionary (in low-level), use function {@link FSPDFDoc::getInfo}.</li>
 *			<li>To access document encrypt dictionary (in low-level), use function {@link FSPDFDoc::getEncryptDict}.</li>
 *			<li>To access reading bookmark:
 *				<ul>
 *				<li>To access the reading bookmark, use function {@link FSPDFDoc::getReadingBookmarkCount} and {@link FSPDFDoc::getReadingBookmark:}.</li>
 *				<li>To insert the reading bookmark, use function {@link FSPDFDoc::insertReadingBookmark:title:pageIndex:}.</li>
 *				<li>To remove the reading bookmark, use function {@link FSPDFDoc::removeReadingBookmark:}.</li>
 *				</ul>
 *			</li>
 *			<li>To access interactive form, use functions {@link FSPDFDoc::hasForm} and {@link FSPDFDoc::getForm}.</li>
 *			</ul>
 *
 * @see	FSPDFPage
 * @see	FSBookmark
 * @see	FSPageLabel
 * @see	FSPDFDictionary
 * @see	FSReadingBookmark
 */
@interface FSPDFDoc : NSObject
{
    /** @brief SWIG proxy related property, it's deprecated to use it. */
    void *swigCPtr;
    /** @brief SWIG proxy related property, it's deprecated to use it. */
    BOOL swigCMemOwn;
}
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/**
 * @brief	Create an empty new document.
 *
 * @return	A new ::FSPDFDoc object.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
+(FSPDFDoc*)create;

/**
 * @brief	Create a PDF document object with an existing PDF document from file path.
 *
 * @param[in]	path	Path name of the PDF file.
 *
 * @return	A new PDF document instance.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
+(FSPDFDoc*)createFromFilePath: (NSString *)path;
/**
 * @brief	Create a PDF document object with a memory buffer.
 *
 * @param[in]	buffer		A memory buffer, containing the serialized document.
 *							The PDF document data should be fully loaded in the memory buffer.<br>
 *							The memory buffer ownership is not transferred to the PDF document object,
 *							so when the document is not used any more, user should clean-up allocated memory if necessary.
 *
 * @return	A new PDF document instance.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
+(FSPDFDoc*)createFromMemory: (NSData *)buffer;
/**
 * @brief	Create a document object with a file read instance.
 *
 * @param[in]	fileRead	A file read instance which is implemented by user to load a PDF document.
 *
 * @return	A new PDF document instance.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
+(FSPDFDoc*)createFromHandler: (FSFileReadCallback*)fileRead;
/**
 * @brief	Load current document content by using the specified password.
 *
 * @param[in]	password		The password string, used to load current document content. It can be either user password or owner password.
 *								If current document is not encrypted by password, just pass an empty string.
 *
 * @return	{@link FS_ERRORCODE::e_errSuccess} means success. <br>
 *			{@link FS_ERRORCODE::e_errFile} means there is any error occurs when accessing to current document content.<br>
 *			{@link FS_ERRORCODE::e_errFormat} means the format of current document content is not PDF or the file is corrupted.<br>
 *			{@link FS_ERRORCODE::e_errSecurityHandler} means current PDF document is encrypted by some unsupported security handler.<br>
 *			{@link FS_ERRORCODE::e_errCertificate} means current PDF document is encrypted by digital certificate and current user does not have the correct certificate. <br>
 *			For other error code value, please refer to {@link FS_ERRORCODE::e_errSuccess FS_ERRORCODE::e_errXXX} for more details.
 */
-(enum FS_ERRORCODE)load: (NSString *)password;

/** @brief	Get file size of this PDF document.*/
-(unsigned long long)getFileSize;

/**
 * @brief	Check whether current PDF document is a XFA document.
 *
 * @details	Currently, Foxit PDF SDK does not fully support XFA document. When loading a XFA document, Foxit PDF SDK may only load the XFA wrapper level, and cannot access to the real XFA content.
 *			Foxit PDF SDK does not support to insert/import/remove/move pages in a XFA document yet.
 *
 * @return	<b>YES</b> means current document is a XFA document, while <b>NO</b> means current document is not a XFA document.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(BOOL)isXFA;

/**
 * @brief	Check whether current document is an encrypted file or not.
 *
 * @return	<b>YES</b> means current document is an encrypted file, while <b>NO</b> means current document is not an encrypted file.
 */
-(BOOL)isEncrypted;
/**
 * @brief	Check whether current document has been modified or not.
 *
 * @details	Once function {@link FSPDFDoc::saveAs:saveFlags:} is called successfully, the modified status of current document will be <b>NO</b> until the document is be modified again.
 *
 * @return	<b>YES</b> means current document has been modified, while <b>NO</b> means current document has not been modified.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(BOOL)isModified;
/**
 * @brief	Get the encryption type.
 *
 * @return	Encryption type.
 *			Please refer to {@link FS_ENCRYPTTYPE::e_encryptNone FS_ENCRYPTTYPE::e_encryptXXX} values and it would be one of these values.
 */
-(enum FS_ENCRYPTTYPE)getEncryptionType;
/**
 * @brief	For the password protected document, get the type of password, which is used when loading document content in function {@link FSPDFDoc::load:}.
 *
 * @return	Password type.
 *			Please refer to {@link FS_PASSWORDTYPE::e_pwdInvalid FS_PASSWORDTYPE::e_pwdXXX} values and it would be one of these values.
 */
-(enum FS_PASSWORDTYPE)getPasswordType;
/**
 * @brief	For the password protected document, check the type of a specified password.
 *
 * @details	This function can be used to check the type of any password string.
 *
 * @param[in]	password		The password string to be checked.
 *
 * @return	Password type.
 *			Please refer to {@link FS_PASSWORDTYPE::e_pwdInvalid FS_PASSWORDTYPE::e_pwdXXX} values and it would be one of these values.
 */
-(enum FS_PASSWORDTYPE)checkPassword: (NSString *)password;
/**
 * @brief	Save current PDF document as another PDF file.
 *
 * @param[in]	filePath		File path for the new saved PDF file.
 * @param[in]	saveFlags		Document saving flags.
 *								Please refer to {@link FS_SAVEFLAGS::e_saveFlagNormal FS_SAVEFLAGS::e_saveFlagXXX} values and this can be one or combination of these values.
 *
 * @return	<b>YES</b> means the saving is successfully finished, while <b>NO</b> means failure.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(BOOL)saveAs: (NSString *)filePath saveFlags:(unsigned int)saveFlags;
/**
 * @brief	Create new bookmark root node.
 *
 * @details	If current PDF document already has the bookmark root node, this function will remove the old bookmark tree
 *			and create a new root node instead.
 *
 * @return	A ::FSBookmark object that represents the root bookmark.
 *			If there is any error, this function will return <b>nil</b>.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(FSBookmark*) createFirstBookmark;
/**
 * @brief	Remove a specified bookmark.
 *
 * @param[in]	bookmark	The bookmark that would be deleted.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(BOOL)removeBookmark:(FSBookmark*) bookmark;
/**
 * @brief	Get the first bookmark.
 *
 * @return	The first bookmark.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(FSBookmark*)getFirstBookmark;
/**
 * @brief	Get the count of pages.
 *
 * @return	The count of page.
 */
-(int)getPageCount;
/**
 * @brief	Get a PDF page by index.
 *
 * @param[in]	pageIndex	The page index. Valid range: from 0 to (<i>count</i>-1).
 *							<i>count</i> is returned by function {@link FSPDFDoc::getPageCount}.
 *
 * @return	A PDF page instance.
 *			If the page instance is not used any more, please call function {@link FSPDFDoc::closePage:} to close it.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(FSPDFPage*)getPage: (int)pageIndex;
/**
 * @brief	Close a PDF page by page index.
 *
 * @param[in]	pageIndex	The page index. Valid range: from 0 to (<i>count</i>-1).
 *							<i>count</i> is returned by function {@link FSPDFDoc::getPageCount}.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(BOOL)closePage: (int)pageIndex;
/**
 * @brief	Get the display mode.
 *
 * @details	Display mode specifies how the document should be displayed when opened.
 *
 * @return	Display mode value.
 *			Please refer to {@link FS_DISPLAYMODE::e_displayUseNone FS_DISPLAYMODE::e_displayUseXXX} values and this would be one of its values.
 */
-(enum FS_DISPLAYMODE)getDisplayMode;
/**
 * @brief	Set the display mode.
 *
 * @details	Display mode specifies how the document should be displayed when opened.
 *
 * @param[in]	displayMode	Display mode value.
 *							Please refer to {@link FS_DISPLAYMODE::e_displayUseNone FS_DISPLAYMODE::e_displayUseXXX} values and this should be one of these values.
 *
 * @return	None.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(void)setDisplayMode: (enum FS_DISPLAYMODE)displayMode;
/**
 * @brief	Get the catalog dictionary.
 *
 * @return	The catalog dictionary.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(FSPDFDictionary*)getCatalog;
/**
 * @brief	Get the trailer dictionary.
 *
 * @return	The trailer dictionary.
 */
-(FSPDFDictionary*)getTrailer;
/**
 * @brief	Get the information dictionary.
 *
 * @details	Document's information dictionary contains metadata for the document.
 *
 * @return	The information dictionary.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(FSPDFDictionary*)getInfo;
/**
 * @brief	Get the encrypt dictionary.
 *
 * @return	The encrypt dictionary.
 */
-(FSPDFDictionary*)getEncryptDict;
/**
 * @brief	Get an indirect object by indirect object number.
 *
 * @param[in]	objnum		The indirect object number. It should be above 0.
 *
 * @return	A ::FSPDFObject object that receives the indirect PDF object.
 *			<b>nil</b> means not found or there is any error.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(FSPDFObject*)getIndirectObject: (unsigned int)objnum;
/**
 * @brief	Add a PDF object to current PDF document, to be an indirect object.
 *
 * @details	<ul>
 *			<li>If input PDF object is a direct object (whose indirect object number is 0),
 *				this functions will change it to be an indirect object and add to PDF document.
 *				Then return the new indirect object number.</li>
 *			<li>If input PDF object is already an indirect object (whose indirect object number is above 0),
 *				this function will not add it into document again.
 *				The return value will be its own indirect object number.</li>
 *			</ul>
 *
 * @param[in]	obj		A PDF object instance.
 *
 * @return	The new indirect object number.
 *			If there is any error, 0 will be returned.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(unsigned int)addIndirectObject: (FSPDFObject*)obj;
/**
 * @brief	Delete an indirect object by indirect object number.
 *
 * @param[in]	objnum		The indirect object number. It should be above 0.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(void)deleteIndirectObject: (unsigned int)objnum;
/**
 * @brief	Get user access permissions.
 *
 * @return	User access permission.
 *			Please refer to {@link FS_USERPERMISSIONS::e_permPrint FS_USERPERMISSIONS::e_permXXX} values and this would be one or combination of its values.
 */
-(unsigned int)getUserPermissions;
/**
 * @brief	Check whether current document has a specified metadata key or not.
 *
 * @param[in]	key		The metadata key to be confirmed.
 *
 * @return	<b>YES</b> means current document has the specified metadata key,
 *			while <b>NO</b> means current document does not have the specified metadata key.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(BOOL)hasMetadataKey: (NSString *)key;
/**
 * @brief	Get creation date time.
 *
 * @return	The creation date time.
 *			If no creation date time can be found or any error occurs, <b>nil</b> will be returned.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(FSDateTime*)getCreationDateTime;
/**
 * @brief	Get modified date time.
 *
 * @return	The modified date time.
 *			If no modified date time can be found or any error occurs, <b>nil</b> will be returned.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(FSDateTime*)getModifiedDateTime;
/**
 * @brief	Set creation date time.
 *
 * @param[in]	dateTime The creation date time.
 *
 * @return	None.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(void)setCreationDateTime: (FSDateTime* __nonnull)dateTime;
/**
 * @brief	Set modified date time.
 *
 * @param[in]	dateTime	The modified date time.
 *
 * @return	None.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(void)setModifiedDateTime: (FSDateTime* __nonnull)dateTime;

/**
 * @brief	Get metadata value.
 *
 * @details	This function is used to get the whole value (which may contain several values for some keys)
 *          for a metadata key.<br>
 *          For some metadata keys such as "Author" and "Keywords", they can contain single or multiple values.
 *          If user wants to get the values one by one for these two keys, please use function
 *          {@link FSPDFDoc::getMetadataValueCount:} and {@link FSPDFDoc::getMetadataValueByIndex:index:}.
 *
 * @param[in]	key		Metadata key string, in UTF-8 encoding.
 *						Currently it can be one of the following keys:<br>
 *						<ul>
 *						<li>"Title"</li>
 *						<li>"Author"</li>
 *						<li>"Subject"</li>
 *						<li>"Keywords"</li>
 *						<li>"Creator"</li>
 *						<li>"Producer"</li>
 *						<li>"Trapped"</li>
 *						<li>"pdfaid"</li>
 *						</ul>
 *
 * @return	Metadata value string, in UTF-8 string.
 *
 * @throws	FSException	For more information about exception values,
 *						please refere to {@link FS_ERRCODE::e_errFile FS_ERRCODE::e_errXXX}.
 */
-(NSString *)getMetadataValue: (NSString *)key;

/**
 * @brief	Get the count of metadata value.
 *
 * @details	For some metadata key such as "Author" and "Keywords", they can contain single or multiple values.
 *          This function is used to get the count of values, and then function
 *          {@link FSPDFDoc::getMetadataValueByIndex:index:} can be used to get one of these values.<br>
 *          If user just wants to get the whole values, please use function {@link FSPDFDoc::getMetadataValue:}.
 *
 * @param[in]	key		Metadata key string, in UTF-8 encoding.
 *						Currently it can be one of the following keys:<br>
 *						<ul>
 *						<li>"Title"</li>
 *						<li>"Author"</li>
 *						<li>"Subject"</li>
 *						<li>"Keywords"</li>
 *						<li>"Creator"</li>
 *						<li>"Producer"</li>
 *						<li>"Trapped"</li>
 *						<li>"pdfaid"</li>
 *						<li>Some other custom information keys, if they're supported by the PDF file.</li>
 *						</ul>
 *
 * @return	The count of metadata value.
 *
 * @throws	FSException	For more information about exception values,
 *						please refere to {@link FS_ERRCODE::e_errFile FS_ERRCODE::e_errXXX}.
 */
-(int)getMetadataValueCount: (NSString *)key;

/**
 * @brief	Get metadata value by index.
 *
 * @details	For some metadata key such as "Author" and "Keywords", they can contain single or multiple values.
 *          This function is used to get one of these values.<br>
 *          If user just wants to get the whole values, please use function {@link FSPDFDoc::getMetadataValue:}.
 *
 * @param[in]	key		Metadata key string, in UTF-8 encoding.
 *						Currently it can be one of the following keys:<br>
 *						<ul>
 *						<li>"Title"</li>
 *						<li>"Author"</li>
 *						<li>"Subject"</li>
 *						<li>"Keywords"</li>
 *						<li>"Creator"</li>
 *						<li>"Producer"</li>
 *						<li>"Trapped"</li>
 *						<li>"pdfaid"</li>
 *						<li>Some other custom information keys, if they're supported by the PDF file.</li>
 *						</ul>
 *
 * @param[in]	index	The index of metadata value.Valid range: from 0 to (<i>count</i>-1).
 *						<i>count</i> is returned by function {@link FSPDFDoc::getMetadataValueCount:}.
 *
 * @return	Metadata value string, in UTF-8 string.
 *
 * @throws	FSException	For more information about exception values,
 *						please refere to {@link FS_ERRCODE::e_errFile FS_ERRCODE::e_errXXX}.
 */
-(NSString *)getMetadataValueByIndex: (NSString *)key index: (int)index;

/**
 * @brief	Set the array of metadata values.
 *
 * @details	This function is used to set single or multiple values to a specified metadata key:
 *          <ul>
 *          <li>For metadata keys "Author" and "Keywords", they can contain single or multiple values.</li>
 *          <li>For metadata key "pdfaid" which means the PDFA file version, the length of its value string is
 *              always 2, such as "2a", "1a" and so on. So, only the first two characters of the first element
 *              in parameter <i>valueArray</i> will be used.</li>
 *          <li>For rest pre-defined keys, they do not support multiple values. So all the elements in
 *              parameter <i>valueArray</i> will be put into one string and connected by ";".
 *              Then this string will be treated as one value.</li>
 *          </ul>
 *
 * @param[in]	key		Metadata key string, in UTF-8 encoding.
 *						Currently it can be one of the following keys:<br>
 *						<ul>
 *						<li>"Title"</li>
 *						<li>"Author"</li>
 *						<li>"Subject"</li>
 *						<li>"Keywords"</li>
 *						<li>"Creator"</li>
 *						<li>"Producer"</li>
 *						<li>"Trapped"</li>
 *						<li>"pdfaid"</li>
 *						<li>Some other custom information keys, if they're supported by the PDF file.</li>
 *						</ul>
 *
 * @param[in]	valueArray	The array of metadata value string, in UTF-8 string. It must not be <b>NULL</b>.
 *                        Please refer to comment of current function for more details.
 * @param[in]	count		The count of elements in parameter <i>valueArray</i>.
 *
 * @return	None.
 *
 * @throws	FSException	For more information about exception values,
 *						please refere to {@link FS_ERRCODE::e_errFile FS_ERRCODE::e_errXXX}.
 */
-(void)setMetadataArray: (NSString * __nonnull)key valueArray: (NSArray<NSString *>* __nonnull)valueArray count: (int)count;

/**
 * @brief	Get count of ranges of page labels, which use different numbering systems.
 *
 * @return	The count of the page label range.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(int)getPageLabelRangeCount;
/**
 * @brief	Get information of a specified page label.
 *
 * @param[in]	index		The index of the page label range to get the information.
 *							Valid range: from 0 to (<i>count</i>-1).
 *							<i>count</i> is returned by function {@link FSPDFDoc::getPageLabelRangeCount}.
 *
 * @return	The page label information.
 *			If any error occurs, <i>nil</i> will be returned.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(FSPageLabel*)getPageLabelInfo: (int)index;

/**
 * @brief	Check whether current PDF document has interactive form (also known as AcroForm).
 *
 * @return	<b>YES</b> means current document has interactive form.
 *			<b>NO</b> means current document does not have interactive form.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(BOOL)hasForm;

/**
 * @brief	Get the interactive form object.
 *
 * @return	A ::FSForm object that represents the interactive form.
 *			If current document does not have interactive form or there is any error, this function will return <b>nil</b>.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(FSForm*)getForm;

/**
 * @brief	Get the count of reading bookmarks.
 *
 * @return	The count of reading bookmarks.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(int)getReadingBookmarkCount;

/**
 * @brief	Get a reading bookmark by index.
 *
 * @param[in]	index	The index of reading bookmarks. Valid range: from 0 to (<i>count</i>-1).
 *						<i>count</i> is returned by function {@link FSPDFDoc::getReadingBookmarkCount}.
 *
 * @return	The reading bookmark object with speicified index.
 *			If there is any error, this function will return <b>nil</b>.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(FSReadingBookmark*)getReadingBookmark:(int)index;

/**
 * @brief	Insert a reading bookmark to current PDF document.
 *
 * @param[in]	readingBookmarkIndex	The reading bookmark index.<br>
 *										If <i>readingBookmarkIndex</i> is less than 0, the new reading bookmark will be inserted to the first.
 *										If <i>readingBookmarkIndex</i> is equal or larger than the count of reading bookmarks,
 *										the new reading bookmark will be inserted to the end.
 * @param[in]	title					Title string for new reading bookmark. It should be UTF-8 encoding.
 * @param[in]	destPageIndex			The destination page index.
 *
 * @return	A new reading bookmark object.
 *			If there is any error, this function will return <b>nil</b>.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(FSReadingBookmark*)insertReadingBookmark: (int)readingBookmarkIndex title:(NSString*)title pageIndex:(int)destPageIndex;

/**
 * @brief	Remove a reading bookmark from current PDF document.
 *
 * @param[in]	readingBookmark	The reading bookmark to be removed.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(BOOL)removeReadingBookmark:(FSReadingBookmark*)readingBookmark;

/**
 * @brief	Get the count of signature.
 *
 * @return	The count of signature.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(int)getSignatureCount;

/**
 * @brief	Get a signature by index.
 *
 * @param[in]	index	The index of signature. Valid range: from 0 to (<i>count</i>-1).
 *						<i>count</i> is returned by function FSPDFDoc::getSignatureCount.
 *
 * @return	The signature object.
 *			If there is any error, this function will return <b>nil</b>.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(FSSignature*)getSignature: (int)index;

/**
 * @brief	Insert a new blank PDF page to document, by index.
 *
 * @details	The new PDF page will have a default size: width is 612 and height is 792.
 *			User can call function {@link FSPDFPage::setSize:height:} to change the size of new PDF page.
 *
 * @param[in]	index	The page index for new page.<br>
 *						If parameter <i>index</i> is less than 0, the new page will be inserted to the first. <br>
 *						If parameter <i>index</i> is equal to or larger than current page count,
 *						the new page will be inserted to the end.
 *
 * @return	A new PDF page object, which represents a blank page.
 *			If there is any error, this function will return <b>nil</b>.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(FSPDFPage*)insertPage: (int)index;

/**
 * @brief	Remove specified PDF page.
 *
 * @details	Once the specified PDF page is removed successfully, the page object cannot be used any more.
 *
 * @param[in]	page	A ::FSPDFPage object that represents the PDF page to be removed. It should be in current PDF document.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(BOOL)removePage: (FSPDFPage*)page;

/**
 * @brief	Move specified page to a new index position.
 *
 * @details	If the specified page is successfully moved to the new index position, page index of all the pages between the new index and old index of the specified page will be changed as well.
 *
 * @param[in]	page		A ::FSPDFPage object that represents the PDF page to be moved. It should be in current PDF document.
 * @param[in]	dstIndex	Index of the destination position in page array. Valid range: from 0 to (<i>count</i>-1).
 *							<i>count</i> is returned by function {@link FSPDFDoc::getPageCount}.<br>
 *							If parameter <i>dstIndex</i> is just the same as the page index of parameter <i>page</i>,
 *							no change will be done and this function will return <b>YES</b> directly.
 *
 * @return	<b>YES</b> means success or no need to move current page, while <b>NO</b> means failure.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(BOOL)movePageTo: (FSPDFPage*)page dstIndex: (int)dstIndex;

/**
 * @brief	Start to import pages from another PDF document (via file path).
 *
 * @details	Currently not support to import pages from a PDF which contains XFA form.
 *
 * @param[in]	dstIndex		A page index in current PDF document. This is used to specify where the imported pages will be inserted.
 *								If parameter <i>dstIndex</i> is less than 0, the imported pages will be inserted to the first. <br>
 *								If parameter <i>dstIndex</i> is equal to or larger than current page count, the imported pages will be inserted to the end.
 * @param[in]	flags			Options for importing pages.
 *								Please refer to {@link FS_IMPORTFLAGS::e_importFlagNormal FS_IMPORTFLAGS::e_importFlagXXX} and this can be one or a combination of them.
 * @param[in]	layerName		The name of non-selectable label or the prefix name of the non-selectable label to be shown in layer panel of application, in UTF-8 encoding.
 *								If parameter <i>flags</i> contains {@link FS_IMPORTFLAGS::e_importFlagWithLayers}, this should not be empty and should be a valid string.
 *								If parameter <i>flags</i> does not contain {@link FS_IMPORTFLAGS::e_importFlagWithLayers}, this string will be ignored.
 *								<ul>
 *								<li>If all the pages of source PDF document is to be imported to current document, all layers from source document will be grouped under a non-selectable label,
 *									and this string will be directly used as the label. </li>
 *								<li>If only part of pages of source PDF document is to be imported to current document, layers in the same page will be grouped under a single non-selectable label,
 *									and this string will be used as the prefix name of the label. The label will be like "layerName_Page_X". </li>
 *								</ul>
 * @param[in]	srcFilePath		The file path of source PDF document, from which some pages will be imported to current PDF document.
 * @param[in]	password		The password string for source PDF document. It should be in UTF-8 encoding. If source PDF document is not encrypted by password, just pass an empty string.
 * @param[in]	pageRanges		An integer array which contains the page ranges of source PDF document, to be imported.<br>
 *								In this array, 2 numbers are a pair: the first integer is the starting page index, and the second integer is the page count.<br>
 *								If this parameter is set to <b>nil</b>, all pages in the source document will be imported.
 *								If this parameter is not <b>nil</b>, it should contains at least 2 numbers, and the count of elements should be a multiples of 2.
 * @param[in]	count			The count of elements in parameter <i>pageRanges</i>.
 *								If parameter <i>pageRanges</i> is not <b>nil</b>, this value should be above 0 and be a multiples of 2.
 *								If parameter <i>pageRanges</i> is <b>nil</b>, this value will be ignored.
 * @param[in]	pause			Pause object which decides if the importing process needs to be paused.
 *								This can be <b>nil</b> which means not to pause during the parsing process.
 *								If this is not <b>nil</b>, it should be a valid pause object implemented by user.
 *
 * @return	{@link FS_PROGRESSSTATE::e_progressFinished} means the importing process is finished successfully.<br>
 *			{@link FS_PROGRESSSTATE::e_progressToBeContinued} means the importing process is not finished yet and function FSPDFDoc::continueImportPages() should be called to continue the process.
 *			{@link FS_PROGRESSSTATE::e_progressError} means any error occurs.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(enum FS_PROGRESSSTATE)startImportPagesFromFilePath: (int)dstIndex flags: (unsigned int)flags layerName: (NSString *)layerName srcFilePath: (NSString *)srcFilePath password: (NSString *)password pageRanges: (int *)pageRanges count: (int)count pause: (FSPauseCallback*)pause;

/**
 * @brief	Start to import pages from another PDF document (via file document).
 *
 * @details	Currently not support to import pages from a PDF which contains XFA form.
 *
 * @param[in]	dstIndex		A page index in current PDF document. This is used to specify where the imported pages will be inserted.
 *								If parameter <i>dstIndex</i> is less than 0, the imported pages will be inserted to the first. <br>
 *								If parameter <i>dstIndex</i> is equal to or larger than current page count, the imported pages will be inserted to the end.
 * @param[in]	flags			Options for importing pages.
 *								Please refer to {@link FS_IMPORTFLAGS::e_importFlagNormal FS_IMPORTFLAGS::e_importFlagXXX} and this can be one or a combination of them.
 * @param[in]	layerName		The name of non-selectable label or the prefix name of the non-selectable label to be shown in layer panel of application, in UTF-8 encoding.
 *								If parameter <i>flags</i> contains {@link FS_IMPORTFLAGS::e_importFlagWithLayers}, this should not be empty and should be a valid string.
 *								If parameter <i>flags</i> does not contain {@link FS_IMPORTFLAGS::e_importFlagWithLayers}, this string will be ignored.
 *								<ul>
 *								<li>If all the pages of source PDF document is to be imported to current document, all layers from source document will be grouped under a non-selectable label,
 *									and this string will be directly used as the label. </li>
 *								<li>If only part of pages of source PDF document is to be imported to current document, layers in the same page will be grouped under a single non-selectable label,
 *									and this string will be used as the prefix name of the label. The label will be like "layerName_Page_X". </li>
 *								</ul>
 * @param[in]	srcDoc			A ::FSPDFDoc object that represents the source PDF document, whose pages will be imported to current PDF document.
 *								Please keep this source document valid until current document will not be saved any more.
 * @param[in]	pageRanges		An integer array which contains the page ranges of source PDF document, to be imported.<br>
 *								In this array, 2 numbers are a pair: the first integer is the starting page index, and the second integer is the page count.<br>
 *								If this parameter is set to <b>nil</b>, all pages in the source document will be imported.
 *								If this parameter is not <b>nil</b>, it should contains at least 2 numbers, and the count of elements should be a multiples of 2.
 * @param[in]	count			The count of elements in parameter <i>pageRanges</i>.
 *								If parameter <i>pageRanges</i> is not <b>nil</b>, this value should be above 0 and be an even number.
 *								If parameter <i>pageRanges</i> is <b>nil</b>, this value will be ignored.
 * @param[in]	pause			Pause object which decides if the importing process needs to be paused.
 *								This can be <b>nil</b> which means not to pause during the parsing process.
 *								If this is not <b>nil</b>, it should be a valid pause object implemented by user.
 *
 * @return	{@link FS_PROGRESSSTATE::e_progressFinished} means the importing process is finished successfully.<br>
 *			{@link FS_PROGRESSSTATE::e_progressToBeContinued} means the importing process is not finished yet and function FSPDFDoc::continueImportPages() should be called to continue the process.
 *			{@link FS_PROGRESSSTATE::e_progressError} means any error occurs.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(enum FS_PROGRESSSTATE)startImportPages: (int)dstIndex flags: (unsigned int)flags layerName: (NSString *)layerName srcDoc: (FSPDFDoc *)srcDoc pageRanges: (int *)pageRanges count: (int)count pause: (FSPauseCallback*)pause;

/**
 * @brief	Continue to import pages if the importing process has not been finished yet.
 *
 * @return	{@link FS_PROGRESSSTATE::e_progressFinished} means the importing process is finished successfully.<br>
 *			{@link FS_PROGRESSSTATE::e_progressToBeContinued} means the importing process is not finished yet and function FSPDFDoc::continueImportPages() should be called to continue the process.
 *			{@link FS_PROGRESSSTATE::e_progressError} means any error occurs.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(enum FS_PROGRESSSTATE)continueImportPages;

/**
 * @brief	Get PDF file version stored in PDF header section.
 *
 * @return	The file version, such as 14 for 1.4, 15 for 1.5, and etc.
 */
-(int)getFileVersion;
/**
 * @brief	Specify the PDF file version which will be stored in PDF header section of the saved PDF file.
 *
 * @details This function does not check whether the PDF matches the specified version.
 *
 * @param[in]	version		An integer specify the file version, such as 14 for 1.4, 15 for 1.5, and etc. Its value should be between 10 and 17,
 *							If this is out of range, then it would be reset as the closest version (10 or 17).
 *
 * @return None.
 */
-(void)setFileVersion: (int)version;

/**
 * @brief	Set a specified PDF security handler for encryption, such as standard encryption(password), certificate encryption...
 *
 * @param[in]	securityHandler		A PDF security handler object.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(BOOL)setSecurityHandler:(FSSecurityHandler*)securityHandler;
/**
 * @brief	Get the current PDF security handler of current document.
 *
 * @return	The PDF security handler object.
 */
-(FSSecurityHandler*)getSecurityHandler;
/**
 * @brief	Remove the security handler from current document, so that the later saved document will be unencrypted.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)removeSecurity;

/** @brief Free the object. */
-(void)dealloc;

@end

/**
 * @brief	Enumeration for Page parse status.
 *
 * @details	Values of this enumeration can be used alone or in combination.
 */
enum FS_PAGEPARSEFLAG {
    /** @brief	PDF page parsing flag for normal mode. */
    e_parsePageNormal = 0x0000,
    /** @brief	PDF page parsing flag for text-only mode. */
    e_parsePageTextOnly = 0x0001,
    /** @brief	Parse the text content of PDF page with outputting the hyphen on a line feed.*/
    e_parseTextOutputHyphen = 0x0002
};

/**
 * @brief	Enumeration for calculating margin mode.
 *
 * @details	Values of this enumeration can be used alone.
 */
enum FS_CALCMARGINMODE {
    /** @brief	Calculate margin according to bounding box of all contents. */
    e_calcContentsBox = 0,
    /** @brief	Calculate margin by detecting paths or images. */
    e_calcDetection = 1
};


/**
 * @brief   Class to access graphics objects.
 *
 * @details This class is a manager for graphics objects. It stores all its graphics objects in a graphics list, and use a pointer to enumerate them.
 *          A pointer can be used to get one graphics object, insert new graphics object and even remove one.<br>
 *          If any graphics object is changed, or graphics object is inserted/removed, function {@link FSPDFGraphicsObjects::generateContent} should be called
 *          to ensure all these changes would be stored to PDF document.<br>
 *          A PDF page's content usually consists of a sequence of graphics objects, so class ::FSPDFPage is derived from class ::FSPDFGraphicsObjects in order that ::FSPDFPage can access its graphics object.<br>
 *          A form XObject, a kind of graphics object, is a self-contained description of any  sequence of graphics objects,
 *          so function {@link FSPDFFormXObject::getGraphicsObjects} can be used to retreive a ::FSPDFGraphicsObjects object from a form XObject
 *          in order to manage graphics objects which are contained in a form XObject.
 *
 * @see FSPDFPage
 * @see FSPDFFormXObject
 * @see FSPDFGraphicsObject
 */
@interface FSPDFGraphicsObjects : NSObject
{
    /** @brief SWIG proxy related property, it's deprecated to use it. */
    void *swigCPtr;
    /** @brief SWIG proxy related property, it's deprecated to use it. */
    BOOL swigCMemOwn;
}
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/**
 * @brief   Get the position of first graphics object in graphics object list, based on type filter.
 *
 * @details After getting a position in the graphics object list, then user can call function {@link FSPDFGraphicsObjects::getGraphicsObject:} to get the graphics object with this position.
 *
 * @param[in]   filter      Type filter that specifies which kind of graphics object is to be gotten.
 *                          Please refer to {@link FS_GRAPHICSOBJECTTYPE::e_graphicsObjTypeAll FS_GRAPHICSOBJECTTYPE::e_graphicsObjTypeXXX} values and it should be one of these values.
 *                          {@link FS_GRAPHICSOBJECTTYPE::e_graphicsObjTypeAll} means for all kinds of graphics objects.
 *
 * @return  A pointer that represents the position of first graphics object in graphics object list.
 *          <b>nil</b> means there is no graphics object.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(void*)getFirstGraphicsObjectPosition: (enum FS_GRAPHICSOBJECTTYPE)filter;
/**
 * @brief   Get the position of last graphics object in graphics object list, based on type filter.
 *
 * @details After getting a position in the graphics object list, then user can call function {@link FSPDFGraphicsObjects::getGraphicsObject:} to get the graphics object with this position.
 *
 * @param[in]   filter      Type filter that specifies which kind of graphics object is to be gotten.
 *                          Please refer to {@link FS_GRAPHICSOBJECTTYPE::e_graphicsObjTypeAll FS_GRAPHICSOBJECTTYPE::e_graphicsObjTypeXXX} values and it should be one of these values.
 *                          {@link FS_GRAPHICSOBJECTTYPE::e_graphicsObjTypeAll} means for all kinds of graphics objects.
 *
 * @return  A pointer that represents the position of last graphics object in graphics object list.
 *          <b>nil</b> means there is no graphics object.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(void*)getLastGraphicsObjectPosition: (enum FS_GRAPHICSOBJECTTYPE)filter;
/**
 * @brief   Get the position of next graphics object in graphics object list, based on type filter and specified current position.
 *
 * @details After getting a position in the graphics object list, then user can call function {@link FSPDFGraphicsObjects::getGraphicsObject:} to get the graphics object with this position.
 *
 * @param[in]   filter      Type filter that specifies which kind of graphics object is to be gotten.
 *                          Please refer to {@link FS_GRAPHICSOBJECTTYPE::e_graphicsObjTypeAll FS_GRAPHICSOBJECTTYPE::e_graphicsObjTypeXXX} values and it should be one of these values.
 *                          {@link FS_GRAPHICSOBJECTTYPE::e_graphicsObjTypeAll} means for all kinds of graphics objects.
 * @param[in]   pos         A pointer that indicates a position in the graphics object list, whose next position is to be gotten. It should not be <b>nil</b>
 *
 * @return  A pointer that represents the position of next graphics object in graphics object list.
 *          <b>nil</b> means parameter <i>position</i> is the last position in graphics object list, or there is any error.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(void*)getNextGraphicsObjectPosition: (enum FS_GRAPHICSOBJECTTYPE)filter pos: (void*)pos;
/**
 * @brief   Get the position of previous graphics object in graphics object list, based on type filter and specified current position.
 *
 * @details After getting a position in the graphics object list, then user can call function {@link FSPDFGraphicsObjects::getGraphicsObject:} to get the graphics object with this position.
 *
 * @param[in]   filter      Type filter that specifies which kind of graphics object is to be gotten.
 *                          Please refer to {@link FS_GRAPHICSOBJECTTYPE::e_graphicsObjTypeAll FS_GRAPHICSOBJECTTYPE::e_graphicsObjTypeXXX} values and it should be one of these values.
 *                          {@link FS_GRAPHICSOBJECTTYPE::e_graphicsObjTypeAll} means for all kinds of graphics objects.
 * @param[in]   pos         A pointer that indicates a position in the graphics object list, whose previous position is to be gotten. It should not be <b>nil</b>
 *
 * @return  A pointer that represents the position of previous graphics object in graphics object list.
 *          <b>nil</b> means parameter <i>position</i> is already in the first position in graphics object list, or there is any error.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(void*)getPrevGraphicsObjectPosition: (enum FS_GRAPHICSOBJECTTYPE)filter pos: (void*)pos;
/**
 * @brief   Get the graphics object by position in graphics object list.
 *
 * @param[in]   pos     A pointer that indicates the position in the graphics object list.
 *                      It should not be <b>nil</b> and should be returned by function {@link FSPDFGraphicsObjects::getNextGraphicsObjectPosition:pos:}.
 *
 * @return  A ::FSPDFGraphicsObject object.
 *          If there is any error, this function will return <b>nil</b>.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(FSPDFGraphicsObject*)getGraphicsObject: (void*)pos;
/**
 * @brief   Insert a graphics object after the specified position.
 *
 * @param[in]   posInsertAfter      Used to specify the position, in order to insert parameter <i>graphicsObj</i> after this position.
 *                                  <b>nil</b> means that parameter <i>graphicsObj</i> will be inserted before all objects, ignoring the specified type filter.
 * @param[in]   graphicsObj         A graphics object to be inserted. User should ensure that parameter <i>graphicsObj</i> belongs to the same PDF document as current graphics objects.
 *
 * @return  The new position of the inserted graphics object.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(void*)insertGraphicsObject: (void*)posInsertAfter graphicsObj: (FSPDFGraphicsObject*)graphicsObj;
/**
 * @brief   Remove a graphics object.
 *
 * @details To remove a graphics object by position (function {@link FSPDFGraphicsObjects::removeGraphicsObjectByPosition:})
 *          is more direct and effective than to remove a graphics object directly (function {@link FSPDFGraphicsObjects::removeGraphicsObject:}).
 *
 * @param[in]   graphicsObj A graphics object to be removed.
 *                          Please ensure this graphics object belongs to current graphics objects.
 *
 * @return  <b>YES</b> means success, while <b>NO</b> means failure.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(BOOL)removeGraphicsObject: (FSPDFGraphicsObject*)graphicsObj;
/**
 * @brief   Remove a graphics object by position.
 *
 * @details To remove a graphics object by position (function {@link FSPDFGraphicsObjects::removeGraphicsObjectByPosition:})
 *          is more direct and effective than to remove a graphics object directly (function {@link FSPDFGraphicsObjects::removeGraphicsObject:}).
 *
 * @param[in]   pos     Used to specify the position of a graphics object, to be removed.
 *                      It should not be <b>nil</b>.
 *
 * @return  <b>YES</b> means success, while <b>NO</b> means failure.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(BOOL)removeGraphicsObjectByPosition: (void*)pos;
/**
 * @brief   Generate contents of current graphics objects.
 *
 * @return  <b>YES</b> means success, while <b>NO</b> means failure.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(BOOL)generateContent;

-(void)dealloc;

@end

/**
 * @brief	Class to access a PDF page.
 *
 * @details	Usually, a ::FSPDFPage object is retrieved from a PDF document by function {@link FSPDFDoc::getPage:}
 *			Function {@link FSPDFPage::isParsed} is used to judge whether the PDF page has been parsed or not.
 *			For a un-parsed page, use function {@link FSPDFPage::startParse:pause:isReparse:} to parse it.<br>
 *			This class offers functions to access data of a PDF page, such as page width/height, page rotation, display matrix and so on.
 *			It also offers functions to access PDF annotations:
 *			<ul>
 *			<li>To get a PDF annotation, use function {@link FSPDFPage::getAnnot:}, {@link FSPDFPage::getAnnotAtPos:tolerance:},
 *				or {@link FSPDFPage::getAnnotAtDevicePos:position:tolerance:}.</li>
 *			<li>To add a new PDF annotation, use function {@link FSPDFPage::addAnnot:rect:}.</li>
 *			<li>To remove a PDF annotation, use function {@link FSPDFPage::removeAnnot:}.</li>
 *			</ul>
 *
 * @see FSPDFDoc
 * @see FSAnnot
 */
@interface FSPDFPage : FSPDFGraphicsObjects

/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/**
 * @brief	Get the PDF document, which current PDF page belongs to.
 *
 * @return	Related PDF document.
 */
-(FSPDFDoc*)getDocument;
/**
 * @brief	Get the page dictionary.
 *
 * @return	Page dictionary.
 *			If there is any error, this function will return <b>nil</b>.
 */
-(FSPDFDictionary*)getDict;
/**
 * @brief	Check if current page has been parsed or not.
 *
 * @return	<b>YES</b> means current page has been parsed, while <b>NO</b> means current page has not been parsed yet.
 */
-(BOOL)isParsed;
/**
 * @brief	Start to parse current page.
 *
 * @param[in]	flag		Parsing flag.
 *							Please refer to {@link FS_PAGEPARSEFLAG::e_parsePageNormal FS_PAGEPARSEFLAG::e_parsePageXXX} values and this should be one or a combination of these values.
 * @param[in]	pause		A pause instance (which is implemented by user) to decide if the parsing process needs to be paused.
 *							This can be <b>nil</b> which means not to pause during the parsing process.
 *							If this is not <b>nil</b>, it should be a valid pause object implemented by user.
 * @param[in]	isReparse	<b>YES</b> means to re-parse current page, while <b>NO</b> means do not re-parse current page.
 *
 * @return	{@link FS_PROGRESSSTATE::e_progressFinished} means the paring is finished or the page has already been parsed.<br>
 *			{@link FS_PROGRESSSTATE::e_progressToBeContinued} means the paring process is not finished yet and function {@link FSPDFPage::continueParse} should be called to continue the process.
 *			{@link FS_PROGRESSSTATE::e_progressError} means any error occurs.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(enum FS_PROGRESSSTATE)startParse: (unsigned int)flag pause: (FSPauseCallback*)pause isReparse: (BOOL)isReparse;
/**
 * @brief	Continue to parse the page if the parsing process has not been finished yet.
 *
 * @return	{@link FS_PROGRESSSTATE::e_progressFinished} means the paring is finished or the page has already been parsed.<br>
 *			{@link FS_PROGRESSSTATE::e_progressToBeContinued} means the paring process is not finished yet and function {@link FSPDFPage::continueParse} should be called to continue the process.
 *			{@link FS_PROGRESSSTATE::e_progressError} means any error occurs.
 */
-(enum FS_PROGRESSSTATE)continueParse;
/**
 * @brief	Get page index.
 *
 * @return	Page index, starting from 0.
 */
-(int)getIndex;
/**
 * @brief	Get the page height.
 *
 * @return	Page height.
 */
-(float)getHeight;
/**
 * @brief	Get the page width.
 *
 * @return	Page width
 */
-(float)getWidth;
/**
 * @brief	Get the page rotation.
 *
 * @return	Page rotation value.
 *			Please refer to {@link FS_ROTATION::e_rotation0 FS_ROTATION::e_rotationXXX} values and this would be one of these values.
 */
-(enum FS_ROTATION)getRotation;
/**
 * @brief	Load the thumbnail bitmap.
 *
 * @return	Thumbnail bitmap.<br>
 *			If no thumbnail can be found or there is any error, this function will return <b>nil</b>.<br>
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(FSBitmap*)loadThumbnail;
/**
 * @brief	Get the display matrix of PDF page, from PDF coordinate system to targeted device coordinate system.
 *
 * @param[in]	xPos	Left position of the transformation area in device coordinate system, commonly in pixels.
 * @param[in]	yPos	Top position of the transformation area in device coordinate system, commonly in pixels.
 * @param[in]	xSize	Width of the transformation area in device coordinate system, commonly in pixels.
 * @param[in]	ySize	Height of the transformation area in device coordinate system, commonly in pixels.
 * @param[in]	rotate	Rotation value.
 *						Please refer to {@link FS_ROTATION::e_rotation0 FS_ROTATION::e_rotationXXX} values and this would be one of these values.
 *
 * @return	Display matrix.
 *			If there is any error, <b>nil</b> will be returned.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(FSMatrix*)getDisplayMatrix: (int)xPos yPos: (int)yPos xSize: (int)xSize ySize: (int)ySize rotate: (enum FS_ROTATION)rotate;
/**
 * @brief	Calculate the content area of PDF page.
 *
 * @param[in]	mode	Calculation mode. It should be one of following values:
 *						<ul>
 *						<li>{@link FS_CALCMARGINMODE::e_calcContentsBox} means calculate margin according to bounding box of all contents.</li>
 * 						<li>{@link FS_CALCMARGINMODE::e_calcDetection} means calculate margin by detecting paths or images.</li>
 *						</ul>
 *
 * @return	The minimal rectangle which contains the visible page content.
 *			If there is any error, <b>nil</b> will be returned.
 *
 * @note	Please ensure current page has been parsed before calling this function.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(FSRectF*)calcContentBBox: (enum FS_CALCMARGINMODE)mode;
/**
 * @brief	Get the count of annotations.
 *
 * @return	The count of the annotations.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(int)getAnnotCount;
/**
 * @brief	Get an annotation by index.
 *
 * @param[in]	index	Annotation index. Valid range: from 0 to (<i>count</i>-1).
 *						<i>count</i> is returned by function {@link FSPDFPage::getAnnotCount}.
 *
 * @return	An annotation instance.
 *			If there is any error, this function will return <b>nil</b>.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(FSAnnot*)getAnnot: (int)index;
/**
 * @brief	Get the annotation at a specific position, in PDF coordination system.
 *
 * @details	If there are several annotations in this specific position, this function will always return the topmost annotation.
 *
 * @param[in]	pos			The specific position, in PDF coordination system.
 * @param[in]	tolerance	Tolerance value. Valid range: 0.0f to 30.0f.
 *
 * @return	A ::FSAnnot object.
 *			If no PDF annotation can be found or there is any error, this function will return <b>nil</b>.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(FSAnnot*)getAnnotAtPos: (FSPointF*)pos tolerance: (float)tolerance;
/**
 * @brief	Get the annotation at a specific position, in device coordination system.
 *
 * @details	If there are several annotations in this specific position, this function will always return the topmost annotation.
 *
 * @param[in]	matrix		The transformation matrix. Usually this is returned by function {@link FSPDFPage::getDisplayMatrix:yPos:xSize:ySize:rotate:}.
 *							If this is <b>nil</b>, current function will have the same feature as function {@link FSPDFPage::getAnnotAtPos:tolerance:}.
 * @param[in]	pos			The specific position, in device coordinate system.
 * @param[in]	tolerance	Tolerance value. Valid range: 0.0f to 30.0f.
 *
 * @return	A ::FSAnnot object.
 *			If no PDF annotation can be found or there is any error, this function will return <b>nil</b>.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(FSAnnot*)getAnnotAtDevicePos:(const FSMatrix*)matrix position: (FSPointF*)pos tolerance: (float)tolerance;
/**
 * @brief	Add an annotation to PDF page.
 *
 * @details	Currently, this function can support to add most annotation types except:<br>
 *			Widget, Sound, Movie, Screen, PrinterMark, TrapNet, Watermark, 3D, PSInk.<br>
 *			Attention:
 *			<ul>
 *			<li>Specially, widget annotations are used to represent as form controls of form field, including signature field. <br>
 *				For signature field, function {@link FSPDFPage::addSignature:} can be called to add a new signature object. <br>
 *				For other types of form field, not support to add them yet.<br>
 *			</li>
 *			<li>For supported annotations types, if user does not set any properties of the newly created annotation (except the required properties)
 *				and directly calls function {@link FSAnnot::resetAppearanceStream}, default appearance will be used.
 *				Please refer to comment of concrete annotation class for more details of their own default appearance.
 *			</li>
 *			</ul>
 *
 * @param[in]	annotType	The type of annotation to be added.
 *							Currently, only support:<br>
 *							{@link FSM_ANNOTTYPE::e_annotNote}, {@link FSM_ANNOTTYPE::e_annotHighlight}, {@link FSM_ANNOTTYPE::e_annotUnderline},
 *							{@link FSM_ANNOTTYPE::e_annotSquiggly}, {@link FSM_ANNOTTYPE::e_annotStrikeOut}, {@link FSM_ANNOTTYPE::e_annotLink},
 *							{@link FSM_ANNOTTYPE::e_annotSquare}, {@link FSM_ANNOTTYPE::e_annotCircle}, {@link FSM_ANNOTTYPE::e_annotFreeText},
 *							{@link FSM_ANNOTTYPE::e_annotStamp}, {@link FSM_ANNOTTYPE::e_annotCaret}, {@link FSM_ANNOTTYPE::e_annotInk},
 *							{@link FSM_ANNOTTYPE::e_annotLine}, {@link FSM_ANNOTTYPE::e_annotPolygon}, {@link FSM_ANNOTTYPE::e_annotPolyLine},
 *							{@link FSM_ANNOTTYPE::e_annotFileAttachment}, {@link FSM_ANNOTTYPE::e_annotPopup}.
 * @param[in]	rect		Rectangle of the new annotation.
 *							<ul>
 *							<li>For annotation in following type, they needs a valid rectangle when being added. So for them, <i>rect</i> should be valid:<br>
 *								{@link FSM_ANNOTTYPE::e_annotNote}, {@link FSM_ANNOTTYPE::e_annotLink}, {@link FSM_ANNOTTYPE::e_annotSquare},
 *								{@link FSM_ANNOTTYPE::e_annotCircle}, {@link FSM_ANNOTTYPE::e_annotFreeText}, {@link FSM_ANNOTTYPE::e_annotStamp},
 *								{@link FSM_ANNOTTYPE::e_annotCaret}, {@link FSM_ANNOTTYPE::e_annotFileAttachment}.</li>
 *							<li>For annotation in following type, their rectangle will be updated when other required properties of them have been set.
 *								So for them, <i>rect</i> can be an empty rectangle:<br>
 *								{@link FSM_ANNOTTYPE::e_annotHighlight}, {@link FSM_ANNOTTYPE::e_annotUnderline}, {@link FSM_ANNOTTYPE::e_annotSquiggly},
 *								{@link FSM_ANNOTTYPE::e_annotStrikeOut}, {@link FSM_ANNOTTYPE::e_annotInk}, {@link FSM_ANNOTTYPE::e_annotLine},
 *								{@link FSM_ANNOTTYPE::e_annotPolygon}, {@link FSM_ANNOTTYPE::e_annotPolyLine}, {@link FSM_ANNOTTYPE::e_annotPopup}.<br>
 *								If an invalid rectangle is passed to <i>rect</i>, an empty rectangle will be used instead.</li>
 *							</ul>
 *
 * @return	A ::FSAnnot object that receives the newly created annotation.
 *			If there is any error, <b>nil</b> will be returned.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(FSAnnot*)addAnnot: (enum FS_ANNOTTYPE)annotType rect: (FSRectF*)rect;
/**
 * @brief	Remove an annotation.
 *
 * @param[in]	annot	An annotation to be removed. It should be in current PDF page.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(BOOL)removeAnnot: (FSAnnot*)annot;
/**
 * @brief	Check whether current PDF page has transparency or not.
 *
 * @return	<b>YES</b> means current page has transparency, while <b>NO</b> means current page does not have transparency.
 *
 * @note	Please ensure current page has been parsed before calling this function.
 */
-(BOOL)hasTransparency;

/**
 * @brief	Flatten current PDF page: annotations or form fields may be made to be a part of the page contents according to specified options.
 *
 * @details     After flattening current page successfully, user should re-parse this page by function {@link FSPDFPage::startParse:pause:isReparse:}.
 *
 * @param[in]	isDisplay	The flatten flags:
 *							<b>YES</b> means the flatten result is used for display, and <b>NO</b> means the flatten result is used for print.
 * @param[in]	options		The flatten options.
 *							Please refer to {@link FS_FLATTENOPTIONS::e_flattenOptionAll FS_FLATTENOPTIONS::e_flattenOptionXXX} values and it should one
 *                                  or a combination of them.<br>
 *							Specially, if {@link FS_FLATTENOPTIONS::e_flattenOptionNoAnnot} and {@link FS_FLATTENOPTIONS::e_flattenOptionNoFormControl}
 *                                  are used together,
 *							that means nothing is to be flatten to page and this function will return <b>YES</b> directly.
 *
 * @return	<b>YES</b> means current page is flattened successfully, while <b>NO</b> means failure.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(BOOL)flatten:(BOOL)isDisplay options:(unsigned int)options;
/**
 * @brief	Group all the input markup annotations together.
 *
 * @details	Markup annotations can be grouped. The group consists of a primary annotation and one or more subordinate annotations.
 *			Some entries in the primary annotation are treated as group attributes that should apply to the group as a whole;
 *			the corresponding entries in the subordinate annotations should be ignored. These entries are contents, last modification time,
 *			fill color/border color, title, pop-up annotation, creation time, subject, and open status.
 *			So user should respect the group property: when a property of an annotation in the group is changed,
 *			the other annotations in the same group should be changed too.<br>
 *			Operations that manipulate any annotation in a group, such as movement, cut, and copy,
 *			should be treated by viewer applications as acting on the entire group.
 *
 * @param[in]	annotArray		A markup annotation object array that specifies markup annotations which are to be grouped together.
 *								This array should contains at least 2 markup annotations, and all the markup annotations in this array should be different from others.
 *								All the markup annotations in this array should be in current page. <br>
 *								Specially, if a markup annotation in this array is already in another group, that group will be set to the new group with the new header as well.
 * @param[in]	headerIndex		The index that specifies a markup annotation in parameter <i>annotArray</i> to be the header of the group.
 *								Valid range: from 0 to (<i>arrayCount</i> -1).
 *
 * @return	<b>YES</b> means group input markup annotations together successfully,
 *			while <b>NO</b> means failure.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(BOOL)setAnnotGroup: (NSArray<FSMarkup*>*)annotArray  headerIndex: (int)headerIndex;

/**
 * @brief	Add a signature to PDF page.
 *
 * @param[in]	rect		Rectangle position for the new signature, in PDF coordinate system.
 *
 * @return	A ::FSSignature object that receives the newly created signature.
 *			If there is any error, <b>nil</b> will be returned.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(FSSignature*)addSignature: (FSRectF*)rect;

/**
 * @brief	Set page rotation.
 *
 * @param[in]	rotate	New page rotation value.
 *						Please refer to {@link FS_ROTATION::e_rotation0 FS_ROTATION::e_rotationXXX} values and this should be one of these values.
 *
 * @return	None.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(void)setRotation: (enum FS_ROTATION)rotate;
/**
 * @brief	Set page width and height.
 *
 * @details	New page width and height should be positive values.
 *			If current page is a newly create PDF page by function {@link FSPDFDoc::insertPage:}, current page can be set with any valid new size values.
 *			If current page is gotten from PDF document, the new page size should not be greater than the original one.
 *
 * @param[in]	width	New page width. It should be a positive value and the unit is 1/72 inch.
 * @param[in]	height	New page height. It should be a positive value and the unit is 1/72 inch.
 *
 * @return	None.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(void)setSize: (float)width height: (float)height;
/**
 * @brief	Set page box.
 *
 * @param[in]	boxType		Page box type.
 *							Please refer to {@link FS_PAGEBOX::e_pageMediaBox FS_PAGEBOX::e_pageXXXBox} values and it should be one of these values.
 * @param[in]	box			New box rectangle, in PDF coordinate system.
 *
 * @return	None.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(void)setBox: (enum FS_PAGEBOX)boxType box: (FSRectF*)box;
/**
 * @brief	Transform a PDF page, including the annotations and form fields on the page.
 *
 * @note	This function only supports scaling and translating.
 *			After this operation, please re-parse current page by function {@link FSPDFPage::startParse:pause:isReparse:} with parameter <i>isReparse</i> <b>YES</b>,
 *			in order that expected content will be displayed.
 *
 * @param[in]	matrix					Transform matrix.
 * @param[in]	needTransformClipPath	<b>YES</b> means to transform the page with clip rectangle, and <b>NO</b> means not.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(BOOL)transform: (FSMatrix*)matrix needTransformClipPath: (BOOL)needTransformClipPath;
/**
 * @brief	Set clip rectangle for all page objects on current PDF page.
 *
 * @details	After this function finishes successfully, please re-parse current page by function {@link FSPDFPage::startParse:pause:isReparse:} with parameter <i>isReparse</i> <b>YES</b>.
 *
 * @param[in]	clipRect		New clip rectangle, in PDF coordinate system.
 *
 * @return	None.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(void)setClipRect: (FSRectF*)clipRect;
/**
 * @brief	Set page thumbnail.
 *
 * @details	Thumbnail image does not use alpha channel. So user is recommended to set a bitmap without alpha channel to be the new thumbnail image.
 *			If a bitmap with alpha channel is set, the new thumbnail will use white background by default.
 *
 * @param[in]	thumbnail		New page thumbnail.
 *
 * @return	None.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(void)setThumbnail: (FSBitmap*)thumbnail;

/**
 * @brief	Add an image to current page from file path.
 *
 * @details	The image added is the first frame acquiescently. Supported image types are jpg/png/gif/jpx/bmp/tif.
 *
 * @param[in]	imageFilePath		An image file path, including extension name. It should be in UTF-8 encoding and should not be <b>nil</b> or empty.
 * @param[in]	posPoint			The specific position, in PDF coordination system.
 * @param[in]	width				The width set into page. The value should be larger than 0.
 * @param[in]	height				The height set into page.The value should be larger than 0.
 * @param[in]	isGenerateContent	A boolean value that indicates whether to generate content for page internally or not.
 *									<b>YES</b> means to generate content internally,
 *									When using <b>NO</b>, user should ensure to call function {@link FSPDFPage::generateContent} after adding image.
 *									In order to improve efficiency, users can call {@link FSPDFPage::generateContent} once after adding image many times.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(BOOL)addImageFromFilePath: (NSString *)imageFilePath posPoint: (FSPointF*)posPoint width: (float)width height: (float)height isGenerateContent:(BOOL)isGenerateContent;

/** @brief Free the object. */
-(void)dealloc;

@end

/************************************************************************************************
 *									Bookmark													*
 *************************************************************************************************/

/**
 * @brief	Enumeration for bookmark style type.
 *
 * @details	Values of this enumeration can be used alone or in combination.
 */
enum FS_BOOKMARKSTYLE
{
    /** @brief	 Show bookmark title as normal text. */
    e_bookmarkStyleNormal = 0x00,
    /** @brief	 Show bookmark title as italic text. */
    e_bookmarkStyleItalic = 0x01,
    /** @brief	 Show bookmark title as bold text. */
    e_bookmarkStyleBold = 0x02
};
/**
 * @brief	Enumeration for bookmark position.
 *
 * @details	Values of this enumeration should be used alone.<br>
 *			Actually, "bookmark position" means the relationship between current bookmark and another bookmark.
 */
enum FS_BOOKMARKPOSITION
{
    /** @brief	 Position as first child. */
    e_bookmarkPosFirstChild	= 0,
    /** @brief	 Position as last child. */
    e_bookmarkPosLastChild = 1,
    /** @brief	Position as previous sibling. */
    e_bookmarkPosPrevSibling = 2,
    /** @brief	Position as next sibling. */
    e_bookmarkPosNextSibling = 3,
    /** @brief	Position as first sibling. */
    e_bookmarkPosFirstSibling = 4,
    /** @brief	Position as last sibling. */
    e_bookmarkPosLastSibling = 5
};
/**
 * @brief	Class to access a PDF bookmark.
 *
 * @details	PDF bookmark is also called "outline". It's a tree-structured hierarchy. It allows user to navigate PDF document easily by selecting one outline.
 *			One bookmark contains a destination or actions to indicate how to response when user selects it.<br>
 *			In order to access the bookmark tree, function {@link FSPDFDoc::getFirstBookmark} must be called first to get the root of the whole bookmark tree.
 *			If the "root bookmark" does not exist, function {@link FSPDFDoc::createFirstBookmark} could be called to create a new "root bookmark".
 *			Here, "root bookmark" is an abstract object. "root bookmark" can only have some child bookmarks but no parent, no next sibling bookmarks or any data
 *			(including bookmark data, destination data and action data). And "root bookmark" cannot be shown on the application UI since it has no data.
 *			So, for a root bookmark, only function {@link FSBookmark::getFirstChild} can be used.<br>
 *			From the root bookmark, the bookmark tree can be traversed and each bookmark node can be accessed.<br>
 *			This class offers several functions to access other bookmarks from current bookmark. For example:
 *			<ul>
 *			<li>To access the parent bookmark, use function {@link FSBookmark::getParent}.</li>
 *			<li>To access the first child bookmark, use function {@link FSBookmark::getFirstChild}.</li>
 *			<li>To access the next sibling bookmark, use function {@link FSBookmark::getNextSibling}.</li>
 *			<li>To insert a new bookmark, use function {@link FSBookmark::insert:pos:}.</li>
 *			<li>To move a bookmark, use function {@link FSBookmark::moveTo:pos:}. </li>
 *			</ul>
 *			This class also offers functions to access the data of a PDF bookmark.
 *
 * @see	FSPDFDoc
 */
@interface FSBookmark : NSObject
{
    /** @brief SWIG proxy related property, it's deprecated to use it. */
    void *swigCPtr;
    /** @brief SWIG proxy related property, it's deprecated to use it. */
    BOOL swigCMemOwn;
}
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/**
 * @brief	Get the parent bookmark.
 *
 * @return	The parent bookmark instance.
 */
-(FSBookmark*)getParent;
/**
 * @brief	Get the first child bookmark.
 *
 * @return	The first child bookmark instance.
 */
-(FSBookmark*)getFirstChild;
/**
 * @brief	Get the next sibling bookmark.
 *
 * @return	The next sibling bookmark instance.
 */
-(FSBookmark*)getNextSibling;
/**
 * @brief	Insert a new bookmark according to the position.
 *
 * @details	For the new bookmark, the color be 0xFF000000 and the style would be {@link FS_BOOKMARKSTYLE::e_bookmarkStyleNormal} by default.<br>
 *
 * @param[in]	title	Title string for the new bookmark. It should be UTF-8 encoding.
 * @param[in]	pos		The position where the new bookmark item is to be inserted, based on current bookmark.
 *						Please refer to {@link FS_BOOKMARKPOSITION::e_bookmarkPosFirstChild FS_BOOKMARKPOSITION::e_bookmarkPosXXX} values and it would be one of these values.<br>
 *						If current bookmark is just the "root bookmark", parameter <i>pos</i> can only be {@link FS_BOOKMARKPOSITION::e_bookmarkPosFirstChild} or {@link FS_BOOKMARKPOSITION::e_bookmarkPosLastChild}.
 *
 * @return	A new bookmark object.
 *			If there is any error, this function will return <b>nil</b>.
 */
-(FSBookmark*)insert: (NSString*)title  pos: (enum FS_BOOKMARKPOSITION)pos;
/**
 * @brief	Move current bookmark to be child or sibling of another bookmark.
 *
 * @details	The root bookmark cannot be moved to be child or sibling of any bookmark in the bookmark tree.
 *
 * @param[in]	destBookmark	The destination bookmark. It should not be current bookmark itself or any descendant of current bookmark.<br>
 *								Current bookmark will be moved to be child or sibling of the destination bookmark.
 * @param[in]	pos				The position where the current bookmark is to be moved to, based on parameter <i>destBookmark</i>.
 *								Please refer to {@link FS_BOOKMARKPOSITION::e_bookmarkPosFirstChild FS_BOOKMARKPOSITION::e_bookmarkPosXXX} values and it would be one of these values.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)moveTo: (FSBookmark*)destBookmark  pos: (enum FS_BOOKMARKPOSITION)pos;
/**
 * @brief	Get the destination of the bookmark.
 *
 * @details	If current bookmark dictionary has /Dest or a goto action (/A), this function can get the destination information directly.
 *			If current bookmark dictionary does not have /Dest or its /A is not a goto action,
 *			no destination information can be retrieved and this function will return <b>nil</b>.
 *
 * @return	The destination instance.
 */
-(FSDestination*)getDestination;
/**
 * @brief	Set the destination.
 *
 * @param[in]	dest	The new destination.
 */
-(void)setDestination: (FSDestination*)dest;
/**
 * @brief	Get the title.
 *
 * @return	Title string.
 */
-(NSString *)getTitle;
/**
 * @brief	Set the title.
 *
 * @param[in]	title	New title string.
 */
-(void)setTitle: (NSString *)title;
/**
 * @brief	Get the color.
 *
 * @return	Color used for displaying title.
 *			Format: 0xAARRGGBB. Alpha value is ignored and will always be 0xFF by default.
 */
-(unsigned int)getColor;
/**
 * @brief	Set the color.
 *
 * @param[in]	color	Color used for displaying title. Format:0xAARRGGBB.
 *						Alpha value is ignored and will always be treated as 0xFF internally.
 */
-(void)setColor: (unsigned int)color;
/**
 * @brief	Get bookmark style.
 *
 * @return	The bookmark style values.
 *			This would be one or a combination of {@link FS_BOOKMARKSTYLE::e_bookmarkStyleNormal FS_BOOKMARKSTYLE::e_bookmarkStyleXXX} values.
 */
-(unsigned int)getStyle;
/**
 * @brief	Set bookmark style.
 *
 * @param[in]	style	The style of the bookmark. This can be one or a combination of {@link FS_BOOKMARKSTYLE::e_bookmarkStyleNormal FS_BOOKMARKSTYLE::e_bookmarkStyleXXX} values.
 *						If the <i>style</i> is invalid, {@link FS_BOOKMARKSTYLE::e_bookmarkStyleNormal} will be set instead.
 */
-(void)setStyle: (unsigned int)style;

/** @brief Free the object. */
-(void)dealloc;

@end

/************************************************************************************************
 *									FSReadingBookmark											*
 *************************************************************************************************/

/**
 * @brief	Class to access a reading bookmark.
 *
 * @details	Reading bookmark is not a PDF bookmark, in other words, it is not PDF outlines.
 *			It is the bookmark in applicable level. It is stored in the metadata (XML format) of catalog.
 *			It allows user to add or remove a reading bookmark according to their reading preferences and
 *			navigate one PDF page easily by selecting one reading bookmark.<br>
 *			In order to access the reading bookmark,
 *			function {@link FSPDFDoc::getReadingBookmarkCount} could be called to count the reading bookmarks,
 *			and function {@link FSPDFDoc::getReadingBookmark:} could be called to get a reading bookmark by index.
 *			This class offers several functions to access properties of reading bookmarks. For example:
 *			<ul>
 *			<li>To access the title of reading bookmark, use function {@link FSReadingBookmark::getTitle}.</li>
 *			<li>To set or rename the title, use function {@link FSReadingBookmark::setTitle:}.</li>
 *			<li>To access the page index of reading bookmark, use function {@link FSReadingBookmark::getPageIndex}.</li>
 *			<li>To set the page index, use function {@link FSReadingBookmark::setPageIndex:}.</li>
 *			</ul>
 *
 * @see	FSPDFDoc
 */
@interface FSReadingBookmark : NSObject
{
    /** @brief SWIG proxy related property, it's deprecated to use it. */
    void *swigCPtr;
    /** @brief SWIG proxy related property, it's deprecated to use it. */
    BOOL swigCMemOwn;
}
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/**
 * @brief	Get the title.
 *
 * @return	Title string, in UTF-8 encoding.
 *			If no title property can be found or there is any error, this function will return an empty string.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(NSString*) getTitle;

/**
 * @brief	Set the title.
 *
 * @param[in]	title	New title string. It should be in UTF-8 encoding.
 *
 * @return	None.
 *
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(void)setTitle:(NSString*)title;

/**
 * @brief	Get the index of the destination page.
 *
 * @return	The page index, starting from 0.
 *			If no page index property can be found or there is any error, this function will return -1.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(int)getPageIndex;

/**
 * @brief	Set the index of the destination page.
 *
 * @param[in]	index	The new destination page index.
 *
 * @return	None.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(void)setPageIndex:(int)index;

/**
 * @brief	Get date and time.
 *
 * @param[in]	isCreationDate		<b>YES</b> means to get creation date time, and <b>NO</b> means to get modified date time.
 *
 * @return	The specified date and time.
 *			If no specified date and time property can be found or there is any error,
 *			this function will return a ::FSDateTime object with all values 0.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(FSDateTime *)getDateTime:(BOOL)isCreationDate;

/**
 * @brief	Set date and time.
 *
 * @param[in]	dateTime		New date and time. Its value should be valid.
 * @param[in]	isCreationDate	<b>YES</b> means to set creation date time, and <b>NO</b> means to set modified date time.
 *
 * return None.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(void)setDateTime:(FSDateTime * _Nonnull)dateTime isCreationDate:(BOOL)isCreationDate;

/** @brief Free the object. */
-(void)dealloc;

@end

/**
 * @brief	Enumeration for name tree type.
 *
 * @details	Values of this enumeration should be used alone.
 */
enum FS_NAMETREETYPE {
    /** @brief	"Dests" name tree. */ 
    e_nameTreeDests = 1,
    /** @brief	"JavaScript" name tree. */
    e_nameTreeJavaScript = 2,
    /** @brief	"EmbeddedFiles" name tree. */
    e_nameTreeEmbeddedFiles = 3
};

/**
 * @brief	Class to access a PDF name tree.
 *
 * @details	Name tree is a kind of common data structure in PDF. Name tree serves a similar purpose to PDF dictionary - associating keys and
 *			values - but by different means: in the name tree, a key is treated as an alias of its value object.
 *			That means, the value object can be referred to by the key name instead of by reference object.<br>
 *			Name tree has following characteristics:<br>
 *			keys in a name tree are ordered and each key in the same name tree is unique; values associated with the keys may be objects of any type,
 *			depending on the purpose of the name tree; name tree can represent an arbitrarily large collection of key-value pairs,
 *			which can be looked up efficiently without requiring the entire data structure to be read from the PDF file.<br>
 *			Class {@link FSPDFNameTree} is used to access an existing name tree with specified type or create one. It offers methods to access key-value pairs in the name tree,
 *			and set/add/remove any key-value pair.
 *			Currently, class {@link FSPDFNameTree} can support to access to following name trees:
 *			<ul>
 *			<li>Destinations name tree (with type {@link FS_NAMETREETYPE::e_nameTreeDests}), which maps name strings to destinations.
 *				Values in this name tree should be a destination array (or a reference object to destination array).
 *			</li>
 *			<li>JavaScript name tree (with type {@link FS_NAMETREETYPE::e_nameTreeJavaScript}), which maps name strings to document-level JavaScript actions.
 *				Values in this name tree should be a javascript action dictionary (or a reference object to javascript action dictionary).
 *			</li>
 *			<li>EmbeddedFiles name tree, with type {@link FS_NAMETREETYPE::e_nameTreeEmbeddedFiles}, which maps name strings to file specifications for embedded file streams.
 *				Values in this name tree should be a file specification dictionary (or a reference object to file specification dictionary), which contains an embedded file stream.
 *			</li>
 *			</ul>
 */
@interface FSPDFNameTree : NSObject
{
    /** @brief SWIG proxy related property, it's deprecated to use it. */
    void *swigCPtr;
    /** @brief SWIG proxy related property, it's deprecated to use it. */
    BOOL swigCMemOwn;
}
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/**
 * @brief	Create a {@link FSPDFNameTree} object to access to a specified type name tree in the PDF document.
 *
 * @details	{@link FSPDFNameTree} can be used to access to an existed name tree, or create a new name tree if no name tree exists in the document.
 *
 * @param[in]	pdfDoc		A FSPDFDoc object, it should be valid.
 * @param[in]	type		The type of the name tree.
 *							Please refer to {@link FS_NAMETREETYPE::e_nameTreeDests FS_NAMETREETYPE::e_nameTreeXXX} values and it should be one of these values.
 *
 * @return	A {@link FSPDFNameTree} object.
 */
+(FSPDFNameTree*)create: (FSPDFDoc*)pdfDoc type: (enum FS_NAMETREETYPE)type;
/**
 * @brief	Check if the specified name exists in current name tree.
 *
 * @param[in]	name		String of the name, in UTF-8 encoding. It should not be <b>NULL</b> or empty.
 *
 * @return	<b>TRUE</b> means the specified name exists in current name tree,
 *			and <b>FALSE</b> means the specified name does not exist in current name tree.
 *
 * @exception	e_errParam		Value of any input parameter is invalid.
 * @exception	e_errFormat		Any input UTF-8 string parameter is not in UTF-8 encoding.
 */
-(BOOL)hasName: (NSString*)name;
/**
 * @brief	Get the count of elements in current name tree.
 *
 * @return	The count.
 */
-(int)getCount;
/**
 * @brief	Get a name in the name tree, by index.
 *
 * @param[in]	index	Index of the name to be retrieved. Valid range: from 0 to (<i>count</i>-1).
 *						<i>count</i> is returned by function {@link FSPDFNameTree::getCount}.
 *
 * @return	A name string, in UTF-8 encoding.
 *
 */
-(NSString*)getName: (int)index;
/**
 * @brief	Get the value (as PDF object) of a specified name.
 *
 * @param[in]	name		String of the name, in UTF-8 encoding. It should not be <b>NULL</b> or empty.
 *
 * @return	A FSPDFObject object. <br>
 *			The type of returned PDF object depends on the purpose of current name tree. Please refer to comment of class {@link FSPDFNameTree} for more details.
 *
 */
-(FSPDFObject*)getObj: (NSString*)name;
/**
 * @brief	Get the value (as PDF object) of a specified name.
 *
 * @param[in]	name	String of the name, in UTF-8 encoding. It should not be <b>NULL</b> or empty.
 *						This name should have existed in current name tree.
 * @param[in]	pdfObj	The new PDF object to set to the name's value. It should be valid.
 *						The type of this PDF object should match current name tree; otherwise, the input PDF object is invlid.
 *						Please refer to comment of class {@link FSPDFNameTree} for more details.<br>
 *						User should not release this PDF object after this function succeeds.
 *
 * @return	<b>TRUE</b> means success, while <b>FALSE</b> means failure.
 *
 */
-(BOOL)setObj: (NSString*)name pdfObj: (FSPDFObject*)pdfObj;
/**
 * @brief	Rename an existing name to a new name.
 *
 * @param[in]	oldName		String of an old name which is to be renamed. This string should be in UTF-8 encoding and should not be <b>NULL</b> or empty.
 *							This name should have existed in current name tree.
 * @param[in]	newName		String of a new name, in UTF-8 encoding. This should not be <b>NULL</b> or empty.
 *							This new name should not have existed in current name tree.
 *
 * @return	<b>TRUE</b> means success, while <b>FALSE</b> means failure.
 *
 */
-(BOOL)rename: (NSString*)oldName newName: (NSString*)newName;
/**
 * @brief	Add a new name with a PDF object as its value.
 *
 * @details	All names (as keys) in a name tree should be ordered. When the new name is added, Foxit PDF SDK will find a suitable place in the name tree to add it.
 *			After adding successfully, the indexes of some old names may be changed.
 *
 * @param[in]	name		String of a new name, in UTF-8 encoding. This should not be <b>NULL</b> or empty.
 *							This new name should not have existed in current name tree.
 * @param[in]	pdfObj		A PDF object, to be set with the new name.
 *							The type of this PDF object should match current name tree; otherwise, the input PDF object is invlid.
 *							Please refer to comment of class {@link FSPDFNameTree} for more details.<br>
 *							User should not release this PDF object after this function succeeds.
 *
 * @return	<b>TRUE</b> means success, while <b>FALSE</b> means failure.
 *
 */
-(BOOL)add: (NSString*)name pdfObj: (FSPDFObject*)pdfObj;
/**
 * @brief	Remove a name from current name tree, along with its value (as PDF object).
 *
 * @details	If the input name does not exist in current name tree, this function will return <b>TRUE</b> directly.
 *
 * @param[in]	name		String of a name to be removed, in UTF-8 encoding. This should not be <b>NULL</b> or empty.
 *							This new name should have existed in current name tree.
 *
 * @return	<b>TRUE</b> means success, while <b>FALSE</b> means failure.
 *
 * @exception	e_errParam		Value of any input parameter is invalid.
 * @exception	e_errFormat		Any input UTF-8 string parameter is not in UTF-8 encoding.
 */
-(BOOL)removeObj: (NSString*)name;
/**
 * @brief	Remove all names from current name tree, along with theirs value (as PDF object).
 *
 * @return	<b>TRUE</b> means success, while <b>FALSE</b> means failure.
 */
-(BOOL)removeAllObjs;
/**@brief Default initialization. */
-(id)init;
/** @brief Free the object. */
-(void)dealloc;

@end


